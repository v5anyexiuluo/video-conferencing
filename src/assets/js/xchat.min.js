var RecordRTC = require('recordrtc');
var adapter = require('webrtc-adapter');
function XChatKit(o) {
    var l = JSON.parse(JSON.stringify(o));
    delete l.callback, delete l.camera, delete l.mgw;
    var u = o.callback,
        m = o.fromuser,
        i = o.tenantid,
        t = o.mgw,
        s = o.sendonly,
        r = o.recvonly,
        a = o.camera,
        g = (o.avatar, null),
        f = null,
        p = null,
        v = null,
        S = null,
        h = 0,
        y = null,
        w = null,
        c = null,
        d = null,
        E = {},
        x = {},
        R = {},
        T = {},
        C = {},
        k = {},
        O = {},
        b = {};
    null === m && (m = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
        var n = 16 * Math.random() | 0,
            o = "x" == e ? n : 3 & n | 8;
        return o.toString(16)
    })), null === t && (t = "wss://ego-vdi.haomoney.com/ws"), console.log(m), console.log(t);
    var N = { type: "video", mimeType: "video/mp4;codecs=h264", disableLogs: !1, getNativeBlob: !1, video: void 0 },
        J = { audio: !0, video: !0 };

    function I(e) {
        for (var n in console.log("onGetUserMediaSuccess"), w = e,
                function n(e, o) {
                    console.log("ws.connect");
                    d = new WebSocket(e);
                    d.onopen = function(e) {
                        console.log("ws.onopen");
                        var n = JSON.parse("{}");
                        n.msgtype = "RequestRegister", n.fromuser = o, M(n)
                    };
                    d.onmessage = function(e) {
                        var n, o, t, s, r, i, a, c, d;
                        null !== e.data.size && 0 < e.data.size || e.data.startsWith("{") && e.data.endsWith("}") && (a = JSON.parse(e.data), c = a.fromuser, k[c] = a.mediatype, "EventRegistered" == a.msgtype ? function(e) {
                            if (console.log(JSON.stringify(e)), e.maxBPS && (g = e.maxBPS), e.recorder && (S = e.recorder), e.turnp && (v = e.turnp), e.turnu && (p = e.turnu), e.turn && (f = e.turn), console.log(f), console.log(g), u(e), 1 == h) {
                                for (var n in b) null !== b[n] && void 0 !== b[n] && (b[n].close(), delete b[n]);
                                E = {}, k = {}, O = {}, b = {}, (e = JSON.parse(JSON.stringify(l))).msgtype = "RequestJoinConference", e.chatroom = y, e.fromuser = m, M(e)
                            }
                        }(a) : "EventRinging" == a.msgtype ? (i = (r = a).fromuser, null !== b[i] && void 0 !== b[i] && L(r), console.log("onEventRinging"), function(e) {
                            var n = { iceServers: [{ urls: f, username: p, credential: v, credentialType: "password" }], iceTransportPolicy: "relay" },
                                o = e.fromuser;
                            b[o] = new RTCPeerConnection(n), w.getTracks().forEach(function(e) { console.log("addTrack " + e.kind + " " + e.label), b[o].addTrack(e, w) }), b[o].ontrack = function(e) { A(o, e) }, b[o].oniceconnectionstatechange = function(e) {
                                if (console.log("oniceconnectionstatechange:" + this.iceConnectionState), "connected" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyConnected", n.fromuser = o, u(n)
                                } else if ("closed" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyClosed", n.fromuser = o, u(n)
                                } else if ("disconnected" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyDisconnected", n.fromuser = o, u(n), M("ping")
                                } else if ("failed" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyDisconnected", n.fromuser = o, u(n)
                                }
                            }, b[o].onicecandidate = function(e) {
                                if (null !== e.candidate && 0 === e.candidate.sdpMLineIndex && (console.log(e.candidate), null === O[o] || void 0 === O[o])) {
                                    O[o] = e.candidate.candidate;
                                    var n = JSON.parse(JSON.stringify(l));
                                    n.msgtype = "RequestAnswerCall", n.chatroom = y, n.fromuser = m, n.touser = o, n.content = b[o].localDescription.sdp, M(n)
                                }
                            };
                            var t = JSON.parse("{}");
                            t.type = "offer", t.sdp = e.content, b[o].setRemoteDescription(new RTCSessionDescription(t), function() { console.log("setRemoteDescription Success"), console.log(t.sdp), b[o].createAnswer(function(e) { console.log("createAnswer Success"), console.log(e.sdp), e.sdp = D(e.sdp), b[o].setLocalDescription(e, function() { console.log("setLocalDescription Success"), console.log(e.sdp) }, V) }, V) }, V)
                        }(r)) : "EventEstablished" == a.msgtype ? function(e) {
                            console.log("onEventEstablished");
                            var n = e.fromuser;
                            if (null !== b[n] && void 0 !== b[n] && (null === b[n].remoteDescription || "" === b[n].remoteDescription.sdp)) {
                                var o = JSON.parse("{}");
                                o.type = "answer", o.sdp = e.content, b[n].setRemoteDescription(new RTCSessionDescription(o), function() { console.log("setRemoteDescription Success"), console.log(o.sdp) }, V)
                            }
                        }(a) : "EventReleased" == a.msgtype ? P(a) : "EventPartyAdded" == a.msgtype ? (s = (n = a).fromuser, null !== b[s] && void 0 !== b[s] && L(n), console.log(JSON.stringify(n)), s !== m && (t = { iceServers: [{ urls: f, username: p, credential: v, credentialType: "password" }], iceTransportPolicy: "relay" }, b[o = s] = new RTCPeerConnection(t), w.getTracks().forEach(function(e) { console.log("addTrack " + e.kind + " " + e.label), b[o].addTrack(e, w) }), b[o].ontrack = function(e) { A(o, e) }, b[o].createOffer(function(e) {
                            console.log("createOffer Success"), e.sdp = D(e.sdp), delete O[o], b[o].setLocalDescription(e, function() { console.log("setLocalDescription Success"), console.log(e.sdp) }, V), b[o].oniceconnectionstatechange = function(e) {
                                if (console.log("oniceconnectionstatechange:" + this.iceConnectionState), "connected" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyConnected", n.fromuser = o, u(n)
                                } else if ("closed" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyClosed", n.fromuser = o, u(n)
                                } else if ("disconnected" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyDisconnected", n.fromuser = o, u(n), M("ping")
                                } else if ("failed" == this.iceConnectionState) {
                                    var n = JSON.parse("{}");
                                    n.msgtype = "EventPartyDisconnected", n.fromuser = o, u(n)
                                }
                            }, b[o].onicecandidate = function(e) {
                                if (null !== e.candidate && 0 === e.candidate.sdpMLineIndex && (console.log(e.candidate), null === O[o] || void 0 === O[o])) {
                                    O[o] = e.candidate.candidate;
                                    var n = JSON.parse(JSON.stringify(l));
                                    n.msgtype = "RequestMakeCall", n.chatroom = y, n.fromuser = m, n.touser = o, n.content = b[o].localDescription.sdp, M(n)
                                }
                            }
                        }, V))) : "EventPartyRemoved" == a.msgtype ? P(a) : "EventInvite" == a.msgtype ? (d = a, console.log("onEventInvite"), d.msgtype = "RequestJoinConference", d.fromuser = m, M(d)) : "EventDecline" == a.msgtype ? function(e) {
                            console.log("onEventDecline");
                            var n = e.fromuser;
                            n !== m && (b[n] && (b[n].close(), delete b[n]), delete O[n], delete E[n], delete E[n + "_screen"], "offline" === e.content ? alert("您拨打的电话已关机，请稍后再拨。") : "noanswer" === e.content ? alert("您拨打的电话暂时无人接听，请稍后再拨。") : "noapp" === e.content ? alert("您拨打的电话没有安装应用程序，请选择其他联系方式。") : alert("您拨打的电话正在通话中，请稍后再拨。"))
                        }(a) : u(a))
                    };
                    d.onclose = function(e) { console.log("ws.onclose"), t && n(t, m) };
                    d.onerror = function(e) { console.log("ws.onerror") }
                }(t, m), (o = JSON.parse("{}")).msgtype = "EventLocalStream", o.fromuser = m, o.stream = e, u(o), b) null !== b[n] && void 0 !== b[n] && w.getVideoTracks().forEach(function(e) { b[n].getSenders()[1].replaceTrack(e) })
    }

    function D(e) {
        var n;
        return n = 1 == s ? e.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n") : 1 == r ? e.replace(/a=sendrecv\r\n/g, "a=recvonly\r\n") : e, null !== g && (n = function(e, n) {
            var o = "AS";
            "firefox" === adapter.browserDetails.browser && (n = 1e3 * (n >>> 0), o = "TIAS");
            var t = e.indexOf("m=video"),
                s = e.substr(0, t),
                r = e.substr(t);
            s = -1 === s.indexOf("b=" + o + ":") ? s.replace(/c=IN (.*)\r\n/, "c=IN $1\r\nb=" + o + ":" + n + "\r\n") : s.replace(new RegExp("b=" + o + ":.*\r\n"), "b=" + o + ":" + n + "\r\n");
            r = -1 === r.indexOf("b=" + o + ":") ? r.replace(/c=IN (.*)\r\n/, "c=IN $1\r\nb=" + o + ":" + n + "\r\n") : r.replace(new RegExp("b=" + o + ":.*\r\n"), "b=" + o + ":" + n + "\r\n");
            return e = s + r
        }(n, g)), n
    }

    function M(e) {
        if (null !== d && 1 == d.readyState) {
            console.log("ws.send"), e.mgw = t;
            var n = JSON.stringify(e);
            console.log((new Date).getTime() + "->" + n), d.send(n)
        }
    }

    function P(e) {
        var n = e.fromuser;
        n !== m && void 0 !== E[n] && (console.log("onEventPartyRemoved"), null !== b[n] && void 0 !== b[n] && (b[n].close(), delete b[n]), delete O[n], delete E[n], delete E[n + "_screen"], (e = JSON.parse("{}")).msgtype = "EventPartyRemoved", e.fromuser = n, u(e))
    }

    function L(e) {
        console.log("onEventPartyRejoined");
        var n = e.fromuser;
        n !== m && (null !== b[n] && void 0 !== b[n] && (b[n].close(), delete b[n]), delete O[n], delete E[n], delete E[n + "_screen"])
    }

    function q(e) { for (var n in console.log("onGetScreenSuccess"), c = e, (o = JSON.parse("{}")).msgtype = "EventLocalStream", o.fromuser = m, o.stream = e, u(o), b) null !== b[n] && void 0 !== b[n] && c.getVideoTracks().forEach(function(e) { b[n].getSenders()[1].replaceTrack(e) }) }

    function A(e, n) {
        if (console.log("onTrackAdded"), "audio" === n.track.kind) return (o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.fromuser = e, o.streamtype = "audio", o.stream = n.streams[0], void u(o);
        if (null === E[e] || void 0 === E[e]) {
            console.log("onRemoteStreamReady " + n.streams[0].id);
            var o, t = n.streams[0].clone(),
                s = n.streams[0].clone();
            E[e] = n.streams[0], 1 < n.streams[0].getVideoTracks().length && (n.streams[0].getVideoTracks()[0].label.endsWith("_screen") ? (t.removeTrack(t.getVideoTracks()[0]), s.removeTrack(s.getVideoTracks()[1])) : (t.removeTrack(t.getVideoTracks()[1]), s.removeTrack(s.getVideoTracks()[0])), E[e + "_screen"] = s, E[e] = t), (o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.streamtype = "video", o.fromuser = e, o.stream = t, u(o), 1 < n.streams[0].getVideoTracks().length && ((o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.streamtype = "screen", o.fromuser = e, o.stream = s, u(o))
        }
    }

    function V(e) { console.log(e) } navigator.mediaDevices.enumerateDevices().then(function(e) {
        console.log(e);
        for (var n = 0; n < e.length; ++n) { console.log(e[n]); var o = e[n].deviceId; "default" !== o && ("audioinput" === e[n].kind ? x[o] = e[n] : "videoinput" === e[n].kind && (R[o] = e[n])) } console.log(x), console.log(R), null === a && (a = 0);
        console.log(a);
        for (var n = 0, t = 0; n < e.length; ++n)
            if ("videoinput" === e[n].kind && a == t++) { J.deviceId = { exact: e[n].deviceId }, console.log(J), navigator.getUserMedia(J, I, V); break }
    }).catch(V), setInterval(function() { null !== d && 1 == d.readyState && d.send("ping") }, 1e3), this.GetLocalStream = function() { return w }, this.SendJSON = function(e) { M(e) }, this.SendText = function(e) { e.msgtype = "text", M(e) }, this.SendInput = function(e) { e.msgtype = "onText", M(e) }, this.JoinConference = function(e) { h = 1, y = e.chatroom }, this.LeaveConference = function(e) {
        for (var n in e.msgtype = "RequestLeaveConference", M(e), b) b[n] && (b[n].close(), delete b[n]);
        for (var n in T) this.StopRecording(n);
        h = 0, E = {}, T = {}, C = {}, k = {}, O = {}, b = {}
    }, this.ClearXChatKit = function(e) {
        if (S) {
            var n = JSON.parse(JSON.stringify(e));
            n.msgtype = "RequestStopRecording", n.fromuser = m, n.touser = S, M(n)
        }
        this.LeaveConference(e), this.StopCamera(), this.CloseWS()
    }, this.MakeCall = function(e) { h = 1, y = e.chatroom, e.msgtype = "RequestInvite", M(e) }, this.ReleaseCall = function(e) { h = 0, e.msgtype = "RequestReleaseCall", M(e) }, this.HoldCall = function(e) { e.msgtype = "RequestHoldCall", M(e) }, this.RetrieveCall = function(e) { e.msgtype = "RequestRetrieveCall", M(e) }, this.DisableCamera = function(e) { e.msgtype = "RequestDisableCamera", M(e), w.getVideoTracks().forEach(function(e) { e.enabled = !1 }) }, this.EnableCamera = function(e) { e.msgtype = "RequestEnableCamera", M(e), w.getVideoTracks().forEach(function(e) { e.enabled = !0 }) }, this.DisableMicphone = function(e) { w.getAudioTracks().forEach(function(e) { e.enabled = !1 }) }, this.EnableMicphone = function(e) { w.getAudioTracks().forEach(function(e) { e.enabled = !0 }) }, this.StopCamera = function(e) { w.getTracks().forEach(function(e) { e.stop() }) }, this.StartShare = function() {
        window.addEventListener("message", function(e) {
            if (e.data.sourceId) {
                var n = { mandatory: { chromeMediaSource: "desktop" } };
                n.mandatory.chromeMediaSourceId = e.data.sourceId, navigator.getUserMedia({ video: n }, q, V)
            }
        }), window.postMessage("get-sourceId", "*")
    }, this.StopShare = function() {
        for (var n in b) null !== b[n] && void 0 !== b[n] && w.getVideoTracks().forEach(function(e) { b[n].getSenders()[1].replaceTrack(e) });
        c.getVideoTracks().forEach(function(e) { e.stop() })
    }, this.StartRecording = function(e) {
        if (console.log("StartRecording1 " + e), !T[e]) {
            console.log("StartRecording2 " + e);
            var n = null;
            (n = m === e ? w : E[e]) && (T[e] = RecordRTC(n, N), T[e].startRecording(), C[e] = (new Date).getTime())
        }
    }, this.StopRecording = function(e) {
        var n = T[e];
        if (n) {
            var o = C[e],
                t = (new Date).getTime(),
                s = -1 < e.lastIndexOf("_Agent") ? 1 : 0,
                r = i + "-" + y + "-" + o + "-" + t + "-" + e + "-" + s + ".mp4";
            console.log("StopRecording " + r), T[e].setFileName(r), n.stopRecording(function(e) { this.save() }), delete C[e], delete T[e]
        }
    }, this.StopRecorders = function() { for (var e in T) StopRecording(e) }, this.StartSession = function(e) { e.msgtype = "RequestStartSession", M(e) }, this.StopSession = function(e) { e.msgtype = "RequestStopSession", M(e) }, this.CloseWS = function() { null !== d && 1 == d.readyState && (t = null, console.log("ws.close"), d.close(), t = null) }, this.GetPeerStream = function(e) { return E[e] }
}! function() {
    function t(e, n, o) { var t = { audio: !1, video: { mandatory: { chromeMediaSource: e ? "screen" : "desktop", maxWidth: 1920 < window.screen.width ? window.screen.width : 1920, maxHeight: 1080 < window.screen.height ? window.screen.height : 1080 }, optional: [] } }; return o && (t.audio = { mandatory: { chromeMediaSource: e ? "screen" : "desktop" }, optional: [] }), n && (t.video.mandatory.chromeMediaSourceId = n, t.audio && t.audio.mandatory && (t.audio.mandatory.chromeMediaSourceId = n)), t }

    function n(e) { o ? o.isLoaded ? e ? o.contentWindow.postMessage({ captureSourceIdWithAudio: !0 }, "*") : o.contentWindow.postMessage({ captureSourceId: !0 }, "*") : setTimeout(function() { n(e) }, 100) : s(function() { n(e) }) }
    var o;

    function s(e) { o ? e() : ((o = document.createElement("iframe")).onload = function() { o.isLoaded = !0, e() }, o.src = "getScreenId.html", o.style.display = "none", (document.body || document.documentElement).appendChild(o)) }

    function e() { o ? o.isLoaded ? o.contentWindow.postMessage({ getChromeExtensionStatus: !0 }, "*") : setTimeout(e, 100) : s(e) } window.getScreenId = function(o, e) {
        -1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveOrOpenBlob && !navigator.msSaveBlob ? navigator.mozGetUserMedia ? o(null, "firefox", { video: { mozMediaSource: "window", mediaSource: "window" } }) : (window.addEventListener("message", function e(n) {
            if (!n.data) return;
            n.data.chromeMediaSourceId && ("PermissionDeniedError" === n.data.chromeMediaSourceId ? o("permission-denied") : o(null, n.data.chromeMediaSourceId, t(null, n.data.chromeMediaSourceId, n.data.canRequestAudioTrack)), window.removeEventListener("message", e));
            n.data.chromeExtensionStatus && (o(n.data.chromeExtensionStatus, null, t(n.data.chromeExtensionStatus)), window.removeEventListener("message", e))
        }), e ? setTimeout(function() { n("system_audio") }, 100) : setTimeout(n, 100)) : o({ video: !0 })
    }, window.getScreenConstraints = function(t) { s(function() { getScreenId(function(e, n, o) { o || (o = { video: !0 }), t(e, o.video) }) }) }, window.getChromeExtensionStatus = function(o) {
        navigator.mozGetUserMedia ? o("installed-enabled") : (window.addEventListener("message", function e(n) {
            if (!n.data) return;
            n.data.chromeExtensionStatus && (o(n.data.chromeExtensionStatus), window.removeEventListener("message", e))
        }), setTimeout(e, 100))
    }
}();

export default XChatKit;