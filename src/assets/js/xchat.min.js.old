var RecordRTC = require('recordrtc');
var adapter = require('webrtc-adapter')
function XChatKit(o) {
  var d = o.callback,
    l = o.fromuser,
    r = o.mgw,
    e = o.turn,
    t = o.sendonly,
    a = o.recvonly,
    s = o.bps,
    i = o.camera,
    c = (o.avatar, 0),
    u = null,
    m = null,
    f = null,
    g = null,
    p = {},
    v = {},
    S = {},
    h = {},
    y = {},
    w = {},
    x = {},
    E = {};
  null === l && (l = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
    var n = 16 * Math.random() | 0,
      o = "x" == e ? n : 3 & n | 8;
    return o.toString(16)
  })), null === r && (r = "wss://webrtc.myegoo.com.cn/ws"), null === e && (e = "turn:webrtc.myegoo.com.cn"), console.log(l), console.log(r), console.log(s);
  var k = {
      iceServers: [{
        urls: e,
        username: "test",
        credential: "1234",
        credentialType: "password"
      }],
      iceTransportPolicy: "relay"
    },
    T = {
      type: "video",
      mimeType: "video/webm;codecs=vp8",
      disableLogs: !1,
      getNativeBlob: !1,
      bitsPerSecond: null === s ? 262144 : s,
      video: void 0
    },
    R = {
      audio: !0,
      video: !0
    };

  function b(e) {
    for (var n in console.log("onGetUserMediaSuccess"), m = e, (o = JSON.parse("{}")).msgtype = "EventLocalStream", o.fromuser = l, o.stream = e, d(o), E) null !== E[n] && void 0 !== E[n] && m.getVideoTracks().forEach(function(e) {
      E[n].getSenders()[1].replaceTrack(e)
    })
  }

  function C(e) {
    var n;
    return n = 1 == t ? e.replace(/a=sendrecv\r\n/g, "a=sendonly\r\n") : 1 == a ? e.replace(/a=sendrecv\r\n/g, "a=recvonly\r\n") : e, null !== s && (n = function(e, n) {
      var o = "AS";
      "firefox" === adapter.browserDetails.browser && (n = 1e3 * (n >>> 0), o = "TIAS");
      var t = e.indexOf("m=video"),
        r = e.substr(0, t),
        a = e.substr(t);
      r = -1 === r.indexOf("b=" + o + ":") ? r.replace(/c=IN (.*)\r\n/, "c=IN $1\r\nb=" + o + ":" + n + "\r\n") : r.replace(new RegExp("b=" + o + ":.*\r\n"), "b=" + o + ":" + n + "\r\n");
      a = -1 === a.indexOf("b=" + o + ":") ? a.replace(/c=IN (.*)\r\n/, "c=IN $1\r\nb=" + o + ":" + n + "\r\n") : a.replace(new RegExp("b=" + o + ":.*\r\n"), "b=" + o + ":" + n + "\r\n");
      return e = (e = (e = r + a).replace("sprop-maxcapturerate=48000", "sprop-maxcapturerate=8000")).replace("maxplaybackrate=48000;", "maxplaybackrate=8000;"), console.log(e), e
    }(n, s)), n
  }

  function I(e) {
    if (null !== g && 1 == g.readyState) {
      console.log("ws.send"), e.mgw = r;
      var n = JSON.stringify(e);
      console.log((new Date).getTime() + "->" + n), g.send(n)
    }
  }

  function O(e) {
    var n = e.fromuser;
    n !== l && void 0 !== p[n] && (console.log("onEventPartyRemoved"), null !== E[n] && void 0 !== E[n] && (E[n].close(), delete E[n]), delete x[n], delete p[n], delete p[n + "_screen"], (e = JSON.parse("{}")).msgtype = "EventPartyRemoved", e.fromuser = n, d(e))
  }

  function D(e) {
    console.log("onEventPartyRejoined");
    var n = e.fromuser;
    n !== l && (null !== E[n] && void 0 !== E[n] && (E[n].close(), delete E[n]), delete x[n], delete p[n], delete p[n + "_screen"])
  }

  function N(e) {
    for (var n in console.log("onGetScreenSuccess"), f = e, (o = JSON.parse("{}")).msgtype = "EventLocalStream", o.fromuser = l, o.stream = e, d(o), E) null !== E[n] && void 0 !== E[n] && f.getVideoTracks().forEach(function(e) {
      E[n].getSenders()[1].replaceTrack(e)
    })
  }

  function M(e, n) {
    if (console.log("onTrackAdded"), "audio" === n.track.kind) return (o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.fromuser = e, o.streamtype = "audio", o.stream = n.streams[0], void d(o);
    if (null === p[e] || void 0 === p[e]) {
      console.log("onRemoteStreamReady " + n.streams[0].id);
      var o, t = n.streams[0].clone(),
        r = n.streams[0].clone();
      p[e] = n.streams[0], 1 < n.streams[0].getVideoTracks().length && (n.streams[0].getVideoTracks()[0].label.endsWith("_screen") ? (t.removeTrack(t.getVideoTracks()[0]), r.removeTrack(r.getVideoTracks()[1])) : (t.removeTrack(t.getVideoTracks()[1]), r.removeTrack(r.getVideoTracks()[0])), p[e + "_screen"] = r, p[e] = t), (o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.streamtype = "video", o.fromuser = e, o.stream = t, d(o), 1 < n.streams[0].getVideoTracks().length && ((o = JSON.parse("{}")).msgtype = "EventPartyAdded", o.streamtype = "screen", o.fromuser = e, o.stream = r, d(o))
    }
  }

  function J(e) {
    console.log(e)
  }
  document.title = l, navigator.mediaDevices.enumerateDevices().then(function(e) {
      console.log(e);
      for (var n = 0; n < e.length; ++n) {
        console.log(e[n]);
        var o = e[n].deviceId;
        "default" !== o && ("audioinput" === e[n].kind ? v[o] = e[n] : "videoinput" === e[n].kind && (S[o] = e[n]))
      }
      console.log(v), console.log(S), null === i && (i = 0);
      console.log(i);
      for (var n = 0, t = 0; n < e.length; ++n)
        if ("videoinput" === e[n].kind && i == t++) {
          R.deviceId = {
            exact: e[n].deviceId
          },
          console.log(R), navigator.getUserMedia(R, b, J);
          break
        }
    }).catch(J),
    function n(e, t) {
      console.log("ws.connect");
      g = new WebSocket(e);
      g.onopen = function(e) {
        console.log("ws.onopen");
        var n = JSON.parse("{}");
        if (n.msgtype = "RequestRegister", n.fromuser = t, I(n), 1 == c) {
          for (var o in E) null !== E[o] && void 0 !== E[o] && E[o].close();
          p = {}, w = {}, x = {}, E = {}, (n = JSON.parse("{}")).msgtype = "RequestJoinConference", n.chatroom = u, n.fromuser = l, I(n)
        }
      };
      g.onmessage = function(e) {
        var n, o, t, r, a, s, i, c;
        null !== e.data.size && 0 < e.data.size || e.data.startsWith("{") && e.data.endsWith("}") && (s = JSON.parse(e.data), i = s.fromuser, w[i] = s.mediatype, "EventRinging" == s.msgtype ? (a = (r = s).fromuser, null !== E[a] && void 0 !== E[a] && D(r), console.log("onEventRinging"), function(e) {
          var o = e.fromuser;
          E[o] = new RTCPeerConnection(k), m.getTracks().forEach(function(e) {
            console.log("addTrack " + e.kind + " " + e.label), E[o].addTrack(e, m)
          }), E[o].ontrack = function(e) {
            M(o, e)
          }, E[o].oniceconnectionstatechange = function(e) {
            if (console.log("oniceconnectionstatechange:" + this.iceConnectionState), "connected" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyConnected", n.fromuser = o, d(n)
            } else if ("disconnected" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyDisconnected", n.fromuser = o, d(n)
            } else if ("closed" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyClosed", n.fromuser = o, d(n)
            }
          }, E[o].onicecandidate = function(e) {
            if (null !== e.candidate && 0 === e.candidate.sdpMLineIndex && (console.log(e.candidate), null === x[o] || void 0 === x[o])) {
              x[o] = e.candidate.candidate;
              var n = JSON.parse("{}");
              n.msgtype = "RequestAnswerCall", n.chatroom = u, n.fromuser = l, n.touser = o, n.content = E[o].localDescription.sdp, I(n)
            }
          };
          var n = JSON.parse("{}");
          n.type = "offer", n.sdp = e.content, E[o].setRemoteDescription(new RTCSessionDescription(n), function() {
            console.log("setRemoteDescription Success"), console.log(n.sdp), E[o].createAnswer(function(e) {
              console.log("createAnswer Success"), console.log(e.sdp), e.sdp = C(e.sdp), E[o].setLocalDescription(e, function() {
                console.log("setLocalDescription Success"), console.log(e.sdp)
              }, J)
            }, J)
          }, J)
        }(r)) : "EventEstablished" == s.msgtype ? function(e) {
          console.log("onEventEstablished");
          var n = e.fromuser;
          if (null !== E[n] && void 0 !== E[n] && (null === E[n].remoteDescription || "" === E[n].remoteDescription.sdp)) {
            var o = JSON.parse("{}");
            o.type = "answer", o.sdp = e.content, E[n].setRemoteDescription(new RTCSessionDescription(o), function() {
              console.log("setRemoteDescription Success"), console.log(o.sdp)
            }, J)
          }
        }(s) : "EventReleased" == s.msgtype ? O(s) : "EventPartyAdded" == s.msgtype ? (t = (n = s).fromuser, null !== E[t] && void 0 !== E[t] && D(n), console.log("onEventPartyAdded"), t !== l && (E[o = t] = new RTCPeerConnection(k), m.getTracks().forEach(function(e) {
          console.log("addTrack " + e.kind + " " + e.label), E[o].addTrack(e, m)
        }), E[o].ontrack = function(e) {
          M(o, e)
        }, E[o].createOffer(function(e) {
          console.log("createOffer Success"), console.log(e.sdp), e.sdp = C(e.sdp), delete x[o], E[o].setLocalDescription(e, function() {
            console.log("setLocalDescription Success"), console.log(e.sdp)
          }, J), E[o].oniceconnectionstatechange = function(e) {
            if (console.log("oniceconnectionstatechange:" + this.iceConnectionState), "connected" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyConnected", n.fromuser = o, d(n)
            } else if ("disconnected" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyDisconnected", n.fromuser = o, d(n)
            } else if ("closed" == this.iceConnectionState) {
              var n = JSON.parse("{}");
              n.msgtype = "EventPartyClosed", n.fromuser = o, d(n)
            }
          }, E[o].onicecandidate = function(e) {
            if (null !== e.candidate && 0 === e.candidate.sdpMLineIndex && (console.log(e.candidate), null === x[o] || void 0 === x[o])) {
              x[o] = e.candidate.candidate;
              var n = JSON.parse("{}");
              n.msgtype = "RequestMakeCall", n.chatroom = u, n.fromuser = l, n.touser = o, n.content = E[o].localDescription.sdp, I(n)
            }
          }
        }, J))) : "EventPartyRemoved" == s.msgtype ? O(s) : "EventInvite" == s.msgtype ? (c = s, console.log("onEventInvite"), c.msgtype = "RequestJoinConference", c.fromuser = l, I(c)) : "EventDecline" == s.msgtype ? function(e) {
          console.log("onEventDecline");
          var n = e.fromuser;
          n !== l && (E[n] && (E[n].close(), delete E[n]), delete x[n], delete p[n], delete p[n + "_screen"], "offline" === e.content ? alert("您拨打的电话已关机，请稍后再拨。") : "noanswer" === e.content ? alert("您拨打的电话暂时无人接听，请稍后再拨。") : "noapp" === e.content ? alert("您拨打的电话没有安装应用程序，请选择其他联系方式。") : alert("您拨打的电话正在通话中，请稍后再拨。"))
        }(s) : d(s))
      };
      g.onclose = function(e) {
        console.log("ws.onclose"), n(r, l)
      };
      g.onerror = function(e) {
        console.log("ws.onerror")
      }
    }(r, l), setInterval(function() {
      null !== g && 1 == g.readyState && g.send("ping")
    }, 1e3), this.GetLocalStream = function() {
      return m
    }, this.SendJSON = function(e) {
      I(e)
    }, this.SendText = function(e) {
      e.msgtype = "text", I(e)
    }, this.SendInput = function(e) {
      e.msgtype = "onText", I(e)
    }, this.JoinConference = function(e) {
      c = 1, u = e.chatroom, e.msgtype = "RequestJoinConference", I(e), this.StartRecording(e.fromuser)
    }, this.LeaveConference = function(e) {
      for (var n in e.msgtype = "RequestLeaveConference", this.SendJSON(e), E) E[n] && E[n].close();
      for (var n in h) this.StopRecording(n);
      c = 0, p = {}, h = {}, y = {}, w = {}, x = {}, E = {}
    }, this.MakeCall = function(e) {
      c = 1, u = e.chatroom, e.msgtype = "RequestInvite", I(e)
    }, this.ReleaseCall = function(e) {
      c = 0, e.msgtype = "RequestReleaseCall", I(e)
    }, this.HoldCall = function(e) {
      e.msgtype = "RequestHoldCall", I(e)
    }, this.RetrieveCall = function(e) {
      e.msgtype = "RequestRetrieveCall", I(e)
    }, this.DisableCamera = function(e) {
      e.msgtype = "RequestDisableCamera", I(e), m.getVideoTracks().forEach(function(e) {
        e.enabled = !1
      })
    }, this.EnableCamera = function(e) {
      e.msgtype = "RequestEnableCamera", I(e), m.getVideoTracks().forEach(function(e) {
        e.enabled = !0
      })
    }, this.DisableMicphone = function(e) {
      m.getAudioTracks().forEach(function(e) {
        e.enabled = !1
      })
    }, this.EnableMicphone = function(e) {
      m.getAudioTracks().forEach(function(e) {
        e.enabled = !0
      })
    }, this.StartShare = function() {
      window.addEventListener("message", function(e) {
        if (e.data.sourceId) {
          var n = {
            mandatory: {
              chromeMediaSource: "desktop"
            }
          };
          n.mandatory.chromeMediaSourceId = e.data.sourceId, navigator.getUserMedia({
            video: n
          }, N, J)
        }
      }), window.postMessage("get-sourceId", "*")
    }, this.StopShare = function() {
      for (var n in E) null !== E[n] && void 0 !== E[n] && m.getVideoTracks().forEach(function(e) {
        E[n].getSenders()[1].replaceTrack(e)
      });
      f.getVideoTracks().forEach(function(e) {
        e.stop()
      })
    }, this.StartRecording = function(e) {
      if (!h[e]) {
        var n = null;
        (n = l === e ? m : p[e]) && (h[e] = RecordRTC(n, T), h[e].startRecording(), y[e] = (new Date).getTime())
      }
    }, this.StopRecording = function(e) {
      var n = h[e];
      if (n) {
        var o = y[e],
          t = (new Date).getTime(),
          r = u + "-" + o + "-" + t + "-" + e + ".webm";
        // h[e].setFileName(r);
        n.stopRecording(function(e) {
          this.save(r)
        });
        delete y[e];
        delete h[e]
      }
    }, this.StopRecorders = function() {
      for (var e in h) StopRecording(e)
    }
}
! function() {
  function t(e, n, o) {
    var t = {
      audio: !1,
      video: {
        mandatory: {
          chromeMediaSource: e ? "screen" : "desktop",
          maxWidth: 1920 < window.screen.width ? window.screen.width : 1920,
          maxHeight: 1080 < window.screen.height ? window.screen.height : 1080
        },
        optional: []
      }
    };
    return o && (t.audio = {
      mandatory: {
        chromeMediaSource: e ? "screen" : "desktop"
      },
      optional: []
    }), n && (t.video.mandatory.chromeMediaSourceId = n, t.audio && t.audio.mandatory && (t.audio.mandatory.chromeMediaSourceId = n)), t
  }

  function n(e) {
    o ? o.isLoaded ? e ? o.contentWindow.postMessage({
      captureSourceIdWithAudio: !0
    }, "*") : o.contentWindow.postMessage({
      captureSourceId: !0
    }, "*") : setTimeout(function() {
      n(e)
    }, 100) : r(function() {
      n(e)
    })
  }
  var o;

  function r(e) {
    o ? e() : ((o = document.createElement("iframe")).onload = function() {
      o.isLoaded = !0, e()
    }, o.src = "getScreenId.html", o.style.display = "none", (document.body || document.documentElement).appendChild(o))
  }

  function e() {
    o ? o.isLoaded ? o.contentWindow.postMessage({
      getChromeExtensionStatus: !0
    }, "*") : setTimeout(e, 100) : r(e)
  }
  window.getScreenId = function(o, e) {
    -1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveOrOpenBlob && !navigator.msSaveBlob ? navigator.mozGetUserMedia ? o(null, "firefox", {
      video: {
        mozMediaSource: "window",
        mediaSource: "window"
      }
    }) : (window.addEventListener("message", function e(n) {
      if (!n.data) return;
      n.data.chromeMediaSourceId && ("PermissionDeniedError" === n.data.chromeMediaSourceId ? o("permission-denied") : o(null, n.data.chromeMediaSourceId, t(null, n.data.chromeMediaSourceId, n.data.canRequestAudioTrack)), window.removeEventListener("message", e));
      n.data.chromeExtensionStatus && (o(n.data.chromeExtensionStatus, null, t(n.data.chromeExtensionStatus)), window.removeEventListener("message", e))
    }), e ? setTimeout(function() {
      n("system_audio")
    }, 100) : setTimeout(n, 100)) : o({
      video: !0
    })
  }, window.getScreenConstraints = function(t) {
    r(function() {
      getScreenId(function(e, n, o) {
        o || (o = {
          video: !0
        }), t(e, o.video)
      })
    })
  }, window.getChromeExtensionStatus = function(o) {
    navigator.mozGetUserMedia ? o("installed-enabled") : (window.addEventListener("message", function e(n) {
      if (!n.data) return;
      n.data.chromeExtensionStatus && (o(n.data.chromeExtensionStatus), window.removeEventListener("message", e))
    }), setTimeout(e, 100))
  }
}();

export default XChatKit;
// module.exports = XChatKit;