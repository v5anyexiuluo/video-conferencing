"use strict";

function RecordRTC(o, s) {
    if (!o) throw "First parameter is required.";
    s = new RecordRTCConfiguration(o, s = s || {
        type: "video"
    });
    var r = this;

    function e(e) {
        e && (s.initCallback = function () {
            e(), e = s.initCallback = null
        });
        var t = new GetRecorderType(o, s);
        (l = new t(o, s)).record(), a("recording"), s.disableLogs || console.log("Initialized recorderType:", l.constructor.name, "for output-type:", s.type)
    }

    function t(i) {
        if (i = i || function () {}, l) {
            if ("paused" === r.state) return r.resumeRecording(), void setTimeout(function () {
                t(i)
            }, 1);
            "recording" === r.state || s.disableLogs || console.warn('Recording state should be: "recording", however current state is: ', r.state), s.disableLogs || console.log("Stopped recording " + this.filename), "gif" !== s.type ? l.stop(e) : (l.stop(), e()), a("stopped")
        } else d();

        function e(e) {
            if (l) {
                Object.keys(l).forEach(function (e) {
                    "function" != typeof l[e] && (r[e] = l[e])
                });
                var t = l.blob;
                if (!t) {
                    if (!e) throw "Recording failed.";
                    l.blob = t = e
                }
                if (t && !s.disableLogs && console.log(t.type, "->", bytesToSize(t.size)), i) {
                    var o = URL.createObjectURL(t);
                    "function" == typeof i.call ? i.call(r, o) : i(o)
                }
                s.autoWriteToDisk && u(function (e) {
                    var t = {};
                    t[s.type + "Blob"] = e, DiskStorage.Store(t)
                })
            } else "function" == typeof i.call ? i.call(r, "") : i("")
        }
    }

    function c(e) {
        postMessage((new FileReaderSync).readAsDataURL(e))
    }

    function u(t, e) {
        if (!t) throw "Pass a callback function over getDataURL.";
        var o, i, r, a = e ? e.blob : (l || {}).blob;
        if (!a) return s.disableLogs || console.warn("Blob encoder did not finish its job yet."), void setTimeout(function () {
            u(t, e)
        }, 1e3);
        if ("undefined" == typeof Worker || navigator.mozGetUserMedia) {
            var n = new FileReader;
            n.readAsDataURL(a), n.onload = function (e) {
                t(e.target.result)
            }
        } else {
            var d = (o = c, i = URL.createObjectURL(new Blob([o.toString(), "this.onmessage =  function (e) {" + o.name + "(e.data);}"], {
                type: "application/javascript"
            })), r = new Worker(i), URL.revokeObjectURL(i), r);
            d.onmessage = function (e) {
                t(e.data)
            }, d.postMessage(a)
        }
    }

    function i(e) {
        e = e || 0, "paused" !== r.state ? "stopped" !== r.state && (e >= r.recordingDuration ? t(r.onRecordingStopped) : (e += 1e3, setTimeout(function () {
            i(e)
        }, 1e3))) : setTimeout(function () {
            i(e)
        }, 1e3)
    }

    function a(e) {
        r && (r.state = e, "function" == typeof r.onStateChanged.call ? r.onStateChanged.call(r, e) : r.onStateChanged(e))
    }
    var l, n = 'It seems that recorder is destroyed or "startRecording" is not invoked for ' + s.type + " recorder.";

    function d() {
        !0 !== s.disableLogs && console.warn(n)
    }
    var f = {
        startRecording: function () {
            return s.disableLogs || console.log("started recording "), l ? (l.clearRecordedData(), l.record(), a("recording"), r.recordingDuration && i()) : e(function () {
                r.recordingDuration && i()
            }), r
        }, setFileName: function (e) {
            this.filename = e
        }, stopRecording: t,
        pauseRecording: function () {
            l ? "recording" === r.state ? (a("paused"), l.pause(), s.disableLogs || console.log("Paused recording.")) : s.disableLogs || console.warn("Unable to pause the recording. Recording state: ", r.state) : d()
        }, resumeRecording: function () {
            l ? "paused" === r.state ? (a("recording"), l.resume(), s.disableLogs || console.log("Resumed recording.")) : s.disableLogs || console.warn("Unable to resume the recording. Recording state: ", r.state) : d()
        }, initRecorder: e,
        setRecordingDuration: function (e, t) {
            if (void 0 === e) throw "recordingDuration is required.";
            if ("number" != typeof e) throw "recordingDuration must be a number.";
            return r.recordingDuration = e, r.onRecordingStopped = t || function () {}, {
                onRecordingStopped: function (e) {
                    r.onRecordingStopped = e
                }
            }
        }, clearRecordedData: function () {
            l ? (l.clearRecordedData(), s.disableLogs || console.log("Cleared old recorded data.")) : d()
        }, getBlob: function () {
            if (l) return l.blob;
            d()
        }, getDataURL: u,
        toURL: function () {
            if (l) return URL.createObjectURL(l.blob);
            d()
        }, getInternalRecorder: function () {
            return l
        }, saveas: function (e) {
            l ? invokeSaveAsDialog(l.blob, e) : d()
        }, save: function () {
            l ? invokeSaveAsDialog(l.blob, this.filename) : d()
        }, getFromDisk: function (e) {
            l ? RecordRTC.getFromDisk(s.type, e) : d()
        }, setAdvertisementArray: function (e) {
            s.advertisement = [];
            for (var t = e.length, o = 0; o < t; o++) s.advertisement.push({
                duration: o,
                image: e[o]
            })
        }, blob: null,
        bufferSize: 0,
        sampleRate: 0,
        buffer: null,
        reset: function () {
            l && "function" == typeof l.clearRecordedData && l.clearRecordedData(), l = null, a("inactive"), r.blob = null
        }, onStateChanged: function (e) {
            s.disableLogs || console.log("Recorder state changed:", e)
        }, state: "inactive",
        getState: function () {
            return r.state
        }, destroy: function () {
            var e = s.disableLogs;
            s.disableLogs = !0, r.reset(), s = {}, a("destroyed"), f = r = null, e || console.warn("RecordRTC is destroyed.")
        }
    };
    if (!this) return r = f;
    for (var m in f) this[m] = f[m];
    return r = this, f
}

function RecordRTCConfiguration(e, t) {
    return t.recorderType || t.type || (t.audio && t.video ? t.type = "video" : t.audio && !t.video && (t.type = "audio")), t.recorderType && !t.type && (t.recorderType === WhammyRecorder || t.recorderType === CanvasRecorder ? t.type = "video" : t.recorderType === GifRecorder ? t.type = "gif" : t.recorderType === StereoAudioRecorder ? t.type = "audio" : t.recorderType === MediaStreamRecorder && (e.getAudioTracks().length && e.getVideoTracks().length ? t.type = "video" : e.getAudioTracks().length && !e.getVideoTracks().length ? t.type = "audio" : !e.getAudioTracks().length && e.getVideoTracks().length && (t.type = "audio"))), void 0 !== MediaStreamRecorder && "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && (t.mimeType || (t.mimeType = "video/webm"), t.type || (t.type = t.mimeType.split("/")[0]), t.bitsPerSecond), t.type || (t.mimeType && (t.type = t.mimeType.split("/")[0]), t.type || (t.type = "audio")), t
}

function GetRecorderType(e, t) {
    var o;
    return (isChrome || isEdge || isOpera) && (o = StereoAudioRecorder), "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && !isChrome && (o = MediaStreamRecorder), "video" === t.type && (isChrome || isOpera) && (o = WhammyRecorder), "gif" === t.type && (o = GifRecorder), "canvas" === t.type && (o = CanvasRecorder), isMediaRecorderCompatible() && o !== CanvasRecorder && o !== GifRecorder && "undefined" != typeof MediaRecorder && "requestData" in MediaRecorder.prototype && (e.getVideoTracks && e.getVideoTracks().length || e.getAudioTracks && e.getAudioTracks().length) && ("audio" === t.type ? "function" == typeof MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported("audio/webm") && (o = MediaStreamRecorder) : "function" == typeof MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported("video/webm") && (o = MediaStreamRecorder)), t.recorderType && (o = t.recorderType), e instanceof Array && e.length && (o = MultiStreamRecorder), !t.disableLogs && o && o.name && console.log("Using recorderType:", o.name || o.constructor.name), o
}

function MRecordRTC(n) {
    this.addStream = function (e) {
        e && (n = e)
    }, this.mediaType = {
        audio: !0,
        video: !0
    }, this.startRecording = function () {
        var e, t = this.mediaType,
            o = this.mimeType || {
                audio: null,
                video: null,
                gif: null
            };
        if ("function" != typeof t.audio && isMediaRecorderCompatible() && n.getAudioTracks && !n.getAudioTracks().length && (t.audio = !1), "function" != typeof t.video && isMediaRecorderCompatible() && n.getVideoTracks && !n.getVideoTracks().length && (t.video = !1), "function" != typeof t.gif && isMediaRecorderCompatible() && n.getVideoTracks && !n.getVideoTracks().length && (t.gif = !1), !t.audio && !t.video && !t.gif) throw "MediaStream must have either audio or video tracks.";
        if (t.audio && (e = null, "function" == typeof t.audio && (e = t.audio), this.audioRecorder = new RecordRTC(n, {
            type: "audio",
            bufferSize: this.bufferSize,
            sampleRate: this.sampleRate,
            numberOfAudioChannels: this.numberOfAudioChannels || 2,
            disableLogs: this.disableLogs,
            recorderType: e,
            mimeType: o.audio,
            timeSlice: this.timeSlice,
            onTimeStamp: this.onTimeStamp
        }), t.video || this.audioRecorder.startRecording()), t.video) {
            e = null, "function" == typeof t.video && (e = t.video);
            var i = n;
            if (isMediaRecorderCompatible() && t.audio && "function" == typeof t.audio) {
                var r = n.getVideoTracks()[0];
                navigator.mozGetUserMedia ? ((i = new MediaStream).addTrack(r), e && e === WhammyRecorder && (e = MediaStreamRecorder)) : i = new MediaStream([r])
            }
            this.videoRecorder = new RecordRTC(i, {
                type: "video",
                video: this.video,
                canvas: this.canvas,
                frameInterval: this.frameInterval || 10,
                disableLogs: this.disableLogs,
                recorderType: e,
                mimeType: o.video,
                timeSlice: this.timeSlice,
                onTimeStamp: this.onTimeStamp
            }), t.audio || this.videoRecorder.startRecording()
        }
        if (t.audio && t.video) {
            var a = this;
            isMediaRecorderCompatible() ? (a.audioRecorder = null, a.videoRecorder.startRecording()) : a.videoRecorder.initRecorder(function () {
                a.audioRecorder.initRecorder(function () {
                    a.videoRecorder.startRecording(), a.audioRecorder.startRecording()
                })
            })
        }
        t.gif && (e = null, "function" == typeof t.gif && (e = t.gif), this.gifRecorder = new RecordRTC(n, {
            type: "gif",
            frameRate: this.frameRate || 200,
            quality: this.quality || 10,
            disableLogs: this.disableLogs,
            recorderType: e,
            mimeType: o.gif
        }), this.gifRecorder.startRecording())
    }, this.stopRecording = function (t) {
        t = t || function () {}, this.audioRecorder && this.audioRecorder.stopRecording(function (e) {
            t(e, "audio")
        }), this.videoRecorder && this.videoRecorder.stopRecording(function (e) {
            t(e, "video")
        }), this.gifRecorder && this.gifRecorder.stopRecording(function (e) {
            t(e, "gif")
        })
    }, this.pauseRecording = function () {
        this.audioRecorder && this.audioRecorder.pauseRecording(), this.videoRecorder && this.videoRecorder.pauseRecording(), this.gifRecorder && this.gifRecorder.pauseRecording()
    }, this.resumeRecording = function () {
        this.audioRecorder && this.audioRecorder.resumeRecording(), this.videoRecorder && this.videoRecorder.resumeRecording(), this.gifRecorder && this.gifRecorder.resumeRecording()
    }, this.getBlob = function (e) {
        var t = {};
        return this.audioRecorder && (t.audio = this.audioRecorder.getBlob()), this.videoRecorder && (t.video = this.videoRecorder.getBlob()), this.gifRecorder && (t.gif = this.gifRecorder.getBlob()), e && e(t), t
    }, this.destroy = function () {
        this.audioRecorder && (this.audioRecorder.destroy(), this.audioRecorder = null), this.videoRecorder && (this.videoRecorder.destroy(), this.videoRecorder = null), this.gifRecorder && (this.gifRecorder.destroy(), this.gifRecorder = null)
    }, this.getDataURL = function (o) {
        function i(e, t) {
            if ("undefined" != typeof Worker) {
                var o = function (e) {
                    var t, o = URL.createObjectURL(new Blob([e.toString(), "this.onmessage =  function (e) {" + e.name + "(e.data);}"], {
                            type: "application/javascript"
                        })),
                        i = new Worker(o);
                    if (void 0 !== URL) t = URL;
                    else {
                        if ("undefined" == typeof webkitURL) throw "Neither URL nor webkitURL detected.";
                        t = webkitURL
                    }
                    return t.revokeObjectURL(o), i
                }(function (e) {
                    postMessage((new FileReaderSync).readAsDataURL(e))
                });
                o.onmessage = function (e) {
                    t(e.data)
                }, o.postMessage(e)
            } else {
                var i = new FileReader;
                i.readAsDataURL(e), i.onload = function (e) {
                    t(e.target.result)
                }
            }
        }
        this.getBlob(function (e) {
            e.audio && e.video ? i(e.audio, function (t) {
                i(e.video, function (e) {
                    o({
                        audio: t,
                        video: e
                    })
                })
            }) : e.audio ? i(e.audio, function (e) {
                o({
                    audio: e
                })
            }) : e.video && i(e.video, function (e) {
                o({
                    video: e
                })
            })
        })
    }, this.writeToDisk = function () {
        RecordRTC.writeToDisk({
            audio: this.audioRecorder,
            video: this.videoRecorder,
            gif: this.gifRecorder
        })
    }, this.save = function (e) {
        (e = e || {
            audio: !0,
            video: !0,
            gif: !0
        }).audio && this.audioRecorder && this.audioRecorder.save("string" == typeof e.audio ? e.audio : ""), e.video && this.videoRecorder && this.videoRecorder.save("string" == typeof e.video ? e.video : ""), e.gif && this.gifRecorder && this.gifRecorder.save("string" == typeof e.gif ? e.gif : "")
    }
}
"undefined" != typeof module && (module.exports = RecordRTC), "function" == typeof define && define.amd && define("RecordRTC", [], function () {
    return RecordRTC
}), RecordRTC.getFromDisk = function (o, i) {
    if (!i) throw "callback is mandatory.";
    console.log("Getting recorded " + ("all" === o ? "blobs" : o + " blob ") + " from disk!"), DiskStorage.Fetch(function (e, t) {
        "all" !== o && t === o + "Blob" && i && i(e), "all" === o && i && i(e, t.replace("Blob", ""))
    })
}, RecordRTC.writeToDisk = function (e) {
    console.log("Writing recorded blob(s) to disk!"), (e = e || {}).audio && e.video && e.gif ? e.audio.getDataURL(function (o) {
        e.video.getDataURL(function (t) {
            e.gif.getDataURL(function (e) {
                DiskStorage.Store({
                    audioBlob: o,
                    videoBlob: t,
                    gifBlob: e
                })
            })
        })
    }) : e.audio && e.video ? e.audio.getDataURL(function (t) {
        e.video.getDataURL(function (e) {
            DiskStorage.Store({
                audioBlob: t,
                videoBlob: e
            })
        })
    }) : e.audio && e.gif ? e.audio.getDataURL(function (t) {
        e.gif.getDataURL(function (e) {
            DiskStorage.Store({
                audioBlob: t,
                gifBlob: e
            })
        })
    }) : e.video && e.gif ? e.video.getDataURL(function (t) {
        e.gif.getDataURL(function (e) {
            DiskStorage.Store({
                videoBlob: t,
                gifBlob: e
            })
        })
    }) : e.audio ? e.audio.getDataURL(function (e) {
        DiskStorage.Store({
            audioBlob: e
        })
    }) : e.video ? e.video.getDataURL(function (e) {
        DiskStorage.Store({
            videoBlob: e
        })
    }) : e.gif && e.gif.getDataURL(function (e) {
        DiskStorage.Store({
            gifBlob: e
        })
    })
}, MRecordRTC.getFromDisk = RecordRTC.getFromDisk, MRecordRTC.writeToDisk = RecordRTC.writeToDisk, void 0 !== RecordRTC && (RecordRTC.MRecordRTC = MRecordRTC);
var browserFakeUserAgent = "Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45";
! function (e) {
    e && "undefined" == typeof window && "undefined" != typeof global && (global.navigator = {
        userAgent: browserFakeUserAgent,
        getUserMedia: function () {}
    }, global.console || (global.console = {}), void 0 !== global.console.log && void 0 !== global.console.error || (global.console.error = global.console.log = global.console.log || function () {
        console.log(arguments)
    }), "undefined" == typeof document && (e.document = {}, document.createElement = document.captureStream = document.mozCaptureStream = function () {
        var e = {
            getContext: function () {
                return e
            }, play: function () {}, pause: function () {}, drawImage: function () {}, toDataURL: function () {
                return ""
            }
        };
        return e
    }, e.HTMLVideoElement = function () {}), "undefined" == typeof location && (e.location = {
        protocol: "file:",
        href: "",
        hash: ""
    }), "undefined" == typeof screen && (e.screen = {
        width: 0,
        height: 0
    }), void 0 === URL && (e.URL = {
        createObjectURL: function () {
            return ""
        }, revokeObjectURL: function () {
            return ""
        }
    }), e.window = global)
}("undefined" != typeof global ? global : null);
var requestAnimationFrame = window.requestAnimationFrame;
if (void 0 === requestAnimationFrame)
    if ("undefined" != typeof webkitRequestAnimationFrame) requestAnimationFrame = webkitRequestAnimationFrame;
    else if ("undefined" != typeof mozRequestAnimationFrame) requestAnimationFrame = mozRequestAnimationFrame;
else if ("undefined" != typeof msRequestAnimationFrame) requestAnimationFrame = msRequestAnimationFrame;
else if (void 0 === requestAnimationFrame) {
    var lastTime = 0;
    requestAnimationFrame = function (e, t) {
        var o = (new Date).getTime(),
            i = Math.max(0, 16 - (o - lastTime)),
            r = setTimeout(function () {
                e(o + i)
            }, i);
        return lastTime = o + i, r
    }
}
var cancelAnimationFrame = window.cancelAnimationFrame;
void 0 === cancelAnimationFrame && ("undefined" != typeof webkitCancelAnimationFrame ? cancelAnimationFrame = webkitCancelAnimationFrame : "undefined" != typeof mozCancelAnimationFrame ? cancelAnimationFrame = mozCancelAnimationFrame : "undefined" != typeof msCancelAnimationFrame ? cancelAnimationFrame = msCancelAnimationFrame : void 0 === cancelAnimationFrame && (cancelAnimationFrame = function (e) {
    clearTimeout(e)
}));
var AudioContext = window.AudioContext;
void 0 === AudioContext && ("undefined" != typeof webkitAudioContext && (AudioContext = webkitAudioContext), "undefined" != typeof mozAudioContext && (AudioContext = mozAudioContext));
var URL = window.URL;
void 0 === URL && "undefined" != typeof webkitURL && (URL = webkitURL), "undefined" != typeof navigator && void 0 === navigator.getUserMedia && (void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia), void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia));
var isEdge = !(-1 === navigator.userAgent.indexOf("Edge") || !navigator.msSaveBlob && !navigator.msSaveOrOpenBlob),
    isOpera = !!window.opera || -1 !== navigator.userAgent.indexOf("OPR/"),
    isChrome = !isOpera && !isEdge && !!navigator.webkitGetUserMedia || isElectron(),
    MediaStream = window.MediaStream;

function bytesToSize(e) {
    if (0 === e) return "0 Bytes";
    var t = parseInt(Math.floor(Math.log(e) / Math.log(1e3)), 10);
    return (e / Math.pow(1e3, t)).toPrecision(3) + " " + ["Bytes", "KB", "MB", "GB", "TB"][t]
}

function invokeSaveAsDialog(e, t) {
    if (console.log("invokeSaveAsDialog"), !e) throw "Blob object is required.";
    if (!e.type) try {
        e.type = "video/webm"
    } catch (e) {}
    var o = (e.type || "video/webm").split("/")[1];
    if (t && -1 !== t.indexOf(".")) {
        var i = t.split(".");
        t = i[0], o = i[1]
    }
    var r = (t || Math.round(9999999999 * Math.random()) + 888888888) + "." + o;
    if (void 0 !== navigator.msSaveOrOpenBlob) return navigator.msSaveOrOpenBlob(e, r);
    if (void 0 !== navigator.msSaveBlob) return navigator.msSaveBlob(e, r);
    var a = document.createElement("a");
    a.href = URL.createObjectURL(e), a.download = r, a.style = "display:none;opacity:0;color:transparent;", (document.body || document.documentElement).appendChild(a), "function" == typeof a.click ? a.click() : (a.target = "_blank", a.dispatchEvent(new MouseEvent("click", {
        view: window,
        bubbles: !0,
        cancelable: !0
    }))), URL.revokeObjectURL(a.href)
}

function isElectron() {
    return "undefined" != typeof window && "object" == typeof window.process && "renderer" === window.process.type || (!("undefined" == typeof process || "object" != typeof process.versions || !process.versions.electron) || "object" == typeof navigator && "string" == typeof navigator.userAgent && 0 <= navigator.userAgent.indexOf("Electron"))
}

function setSrcObject(t, o, e) {
    if ("createObjectURL" in URL && !e) try {
        o.src = URL.createObjectURL(t)
    } catch (e) {
        return void setSrcObject(t, o, !0)
    } else "srcObject" in o ? o.srcObject = t : "mozSrcObject" in o ? o.mozSrcObject = t : alert("createObjectURL/srcObject both are not supported.")
}
void 0 === MediaStream && "undefined" != typeof webkitMediaStream && (MediaStream = webkitMediaStream), void 0 !== MediaStream && ("getVideoTracks" in MediaStream.prototype || (MediaStream.prototype.getVideoTracks = function () {
    if (!this.getTracks) return [];
    var t = [];
    return this.getTracks().forEach(function (e) {
        -1 !== e.kind.toString().indexOf("video") && t.push(e)
    }), t
}, MediaStream.prototype.getAudioTracks = function () {
    if (!this.getTracks) return [];
    var t = [];
    return this.getTracks().forEach(function (e) {
        -1 !== e.kind.toString().indexOf("audio") && t.push(e)
    }), t
}), void 0 === MediaStream.prototype.stop && (MediaStream.prototype.stop = function () {
    this.getTracks().forEach(function (e) {
        e.stop()
    })
}));
var Storage = {};

function isMediaRecorderCompatible() {
    var e = !!window.opera || 0 <= navigator.userAgent.indexOf(" OPR/"),
        t = !!window.chrome && !e || isElectron();
    if (void 0 !== window.InstallTrigger) return !0;
    navigator.appVersion;
    var o, i, r = navigator.userAgent,
        a = "" + parseFloat(navigator.appVersion),
        n = parseInt(navigator.appVersion, 10);
    return (t || e) && (o = r.indexOf("Chrome"), a = r.substring(o + 7)), -1 !== (i = a.indexOf(";")) && (a = a.substring(0, i)), -1 !== (i = a.indexOf(" ")) && (a = a.substring(0, i)), n = parseInt("" + a, 10), isNaN(n) && (a = "" + parseFloat(navigator.appVersion), n = parseInt(navigator.appVersion, 10)), 49 <= n
}

function MediaStreamRecorder(t, i) {
    var r = this;
    if (void 0 === t) throw 'First argument "MediaStream" is required.';
    if ("undefined" == typeof MediaRecorder) throw "Your browser does not supports Media Recorder API. Please try other modules e.g. WhammyRecorder or StereoAudioRecorder.";
    if ("audio" === (i = i || {
        mimeType: "video/webm"
    }).type) {
        var e;
        if (t.getVideoTracks().length && t.getAudioTracks().length) navigator.mozGetUserMedia ? (e = new MediaStream).addTrack(t.getAudioTracks()[0]) : e = new MediaStream(t.getAudioTracks()), t = e;
        i.mimeType && -1 !== i.mimeType.toString().toLowerCase().indexOf("audio") || (i.mimeType = isChrome ? "audio/webm" : "audio/ogg"), i.mimeType && "audio/ogg" !== i.mimeType.toString().toLowerCase() && navigator.mozGetUserMedia && (i.mimeType = "audio/ogg")
    }
    var a, n = [];

    function d() {
        r.timestamps.push((new Date).getTime()), "function" == typeof i.onTimeStamp && i.onTimeStamp(r.timestamps[r.timestamps.length - 1], r.timestamps)
    }

    function s(e) {
        return a && a.mimeType ? a.mimeType : e.mimeType || "video/webm"
    }

    function o() {
        n = [], a = null, r.timestamps = []
    }
    this.getArrayOfBlobs = function () {
        return n
    }, this.record = function () {
        r.blob = null, r.clearRecordedData(), r.timestamps = [], c = [], n = [];
        var o = i;
        i.disableLogs || console.log("Passing following config over MediaRecorder API.", o), a && (a = null), isChrome && !isMediaRecorderCompatible() && (o = "video/vp8"), "function" == typeof MediaRecorder.isTypeSupported && o.mimeType && (MediaRecorder.isTypeSupported(o.mimeType) || (i.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", o.mimeType), o.mimeType = "audio" === i.type ? "audio/webm" : "video/webm"));
        try {
            a = new MediaRecorder(t, o), i.mimeType = o.mimeType
        } catch (e) {
            a = new MediaRecorder(t)
        }
        o.mimeType && !MediaRecorder.isTypeSupported && "canRecordMimeType" in a && !1 === a.canRecordMimeType(o.mimeType) && (i.disableLogs || console.warn("MediaRecorder API seems unable to record mimeType:", o.mimeType)), a.ignoreMutedMedia = !0 === i.ignoreMutedMedia, a.ondataavailable = function (e) {
            if (e.data && c.push("ondataavailable: " + bytesToSize(e.data.size)), "number" != typeof i.timeSlice)!e.data || !e.data.size || e.data.size < 100 || r.blob ? r.recordingCallback && (r.recordingCallback(new Blob([], {
                type: s(o)
            })), r.recordingCallback = null) : (r.blob = i.getNativeBlob ? e.data : new Blob([e.data], {
                type: s(o)
            }), r.recordingCallback && (r.recordingCallback(r.blob), r.recordingCallback = null));
            else if (e.data && e.data.size && 100 < e.data.size && (n.push(e.data), d(), "function" == typeof i.ondataavailable)) {
                var t = i.getNativeBlob ? e.data : new Blob([e.data], {
                    type: s(o)
                });
                i.ondataavailable(t)
            }
        }, a.onstart = function () {
            c.push("started")
        }, a.onpause = function () {
            c.push("paused")
        }, a.onresume = function () {
            c.push("resumed")
        }, a.onstop = function () {
            c.push("stopped")
        }, a.onerror = function (e) {
            c.push("error: " + e), i.disableLogs || (-1 !== e.name.toString().toLowerCase().indexOf("invalidstate") ? console.error("The MediaRecorder is not in a state in which the proposed operation is allowed to be executed.", e) : -1 !== e.name.toString().toLowerCase().indexOf("notsupported") ? console.error("MIME type (", o.mimeType, ") is not supported.", e) : -1 !== e.name.toString().toLowerCase().indexOf("security") ? console.error("MediaRecorder security error", e) : "OutOfMemory" === e.name ? console.error("The UA has exhaused the available memory. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "IllegalStreamModification" === e.name ? console.error("A modification to the stream has occurred that makes it impossible to continue recording. An example would be the addition of a Track while recording is occurring. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "OtherRecordingError" === e.name ? console.error("Used for an fatal error other than those listed above. User agents SHOULD provide as much additional information as possible in the message attribute.", e) : "GenericError" === e.name ? console.error("The UA cannot provide the codec or recording option that has been requested.", e) : console.error("MediaRecorder Error", e)),
                function (e) {
                    if (!r.manuallyStopped && a && "inactive" === a.state) return delete i.timeslice, a.start(6e5);
                    setTimeout(void 0, 1e3)
                }(), "inactive" !== a.state && "stopped" !== a.state && a.stop()
        }, "number" == typeof i.timeSlice ? (d(), a.start(i.timeSlice)) : a.start(36e5), i.initCallback && i.initCallback()
    }, this.timestamps = [], this.stop = function (e) {
        e = e || function () {}, r.manuallyStopped = !0, a && (this.recordingCallback = e, "recording" === a.state && a.stop(), "number" == typeof i.timeSlice && setTimeout(function () {
            r.blob = new Blob(n, {
                type: s(i)
            }), r.recordingCallback(r.blob)
        }, 100))
    }, this.pause = function () {
        a && "recording" === a.state && a.pause()
    }, this.resume = function () {
        a && "paused" === a.state && a.resume()
    }, this.clearRecordedData = function () {
        a && "recording" === a.state && r.stop(o), o()
    }, this.getInternalRecorder = function () {
        return a
    }, this.blob = null, this.getState = function () {
        return a && a.state || "inactive"
    };
    var c = [];
    this.getAllStates = function () {
        return c
    }, void 0 === i.checkForInactiveTracks && (i.checkForInactiveTracks = !1);
    r = this;
    ! function e() {
        if (a && !1 !== i.checkForInactiveTracks) return !1 === function () {
            if ("active" in t) {
                if (!t.active) return !1
            } else if ("ended" in t && t.ended) return !1;
            return !0
        }() ? (i.disableLogs || console.log("MediaStream seems stopped."), void r.stop()) : void setTimeout(e, 1e3)
    }(), this.name = "MediaStreamRecorder", this.toString = function () {
        return this.name
    }
}

function StereoAudioRecorder(e, i) {
    if (!e.getAudioTracks().length) throw "Your stream has no audio tracks.";
    var r, a = this,
        n = [],
        d = [],
        s = !1,
        c = 0,
        u = 2,
        l = (i = i || {}).desiredSampRate;

    function f() {
        if (!1 === i.checkForInactiveTracks) return !0;
        if ("active" in e) {
            if (!e.active) return !1
        } else if ("ended" in e && e.ended) return !1;
        return !0
    }

    function t(e, t) {
        function o(e, t) {
            var o, i = e.numberOfAudioChannels,
                r = e.leftBuffers.slice(0),
                a = e.rightBuffers.slice(0),
                n = e.sampleRate,
                d = e.internalInterleavedLength,
                s = e.desiredSampRate;

            function c(e, t, o) {
                var i, r, a = Math.round(e.length * (t / o)),
                    n = [],
                    d = Number((e.length - 1) / (a - 1));
                n[0] = e[0];
                for (var s = 1; s < a - 1; s++) {
                    var c = s * d,
                        u = Number(Math.floor(c)).toFixed(),
                        l = Number(Math.ceil(c)).toFixed(),
                        f = c - u;
                    n[s] = (i = e[u], r = e[l], i + (r - i) * f)
                }
                return n[a - 1] = e[e.length - 1], n
            }

            function u(e, t) {
                for (var o = new Float64Array(t), i = 0, r = e.length, a = 0; a < r; a++) {
                    var n = e[a];
                    o.set(n, i), i += n.length
                }
                return o
            }

            function l(e, t, o) {
                for (var i = o.length, r = 0; r < i; r++) e.setUint8(t + r, o.charCodeAt(r))
            }
            2 === i && (r = u(r, d), a = u(a, d), s && (r = c(r, s, n), a = c(a, s, n))), 1 === i && (r = u(r, d), s && (r = c(r, s, n))), s && (n = s), 2 === i && (o = function (e, t) {
                for (var o = e.length + t.length, i = new Float64Array(o), r = 0, a = 0; a < o;) i[a++] = e[r], i[a++] = t[r], r++;
                return i
            }(r, a)), 1 === i && (o = r);
            var f = o.length,
                m = new ArrayBuffer(44 + 2 * f),
                h = new DataView(m);
            l(h, 0, "RIFF"), h.setUint32(4, 44 + 2 * f, !0), l(h, 8, "WAVE"), l(h, 12, "fmt "), h.setUint32(16, 16, !0), h.setUint16(20, 1, !0), h.setUint16(22, i, !0), h.setUint32(24, n, !0), h.setUint32(28, 2 * n, !0), h.setUint16(32, 2 * i, !0), h.setUint16(34, 16, !0), l(h, 36, "data"), h.setUint32(40, 2 * f, !0);
            for (var g = f, p = 44, v = 0; v < g; v++) h.setInt16(p, 32767 * o[v], !0), p += 2;
            if (t) return t({
                buffer: m,
                view: h
            });
            postMessage({
                buffer: m,
                view: h
            })
        }
        if (isChrome) {
            var i, r, a, n = (i = o, r = URL.createObjectURL(new Blob([i.toString(), ";this.onmessage =  function (e) {" + i.name + "(e.data);}"], {
                type: "application/javascript"
            })), (a = new Worker(r)).workerURL = r, a);
            n.onmessage = function (e) {
                t(e.data.buffer, e.data.view), URL.revokeObjectURL(n.workerURL)
            }, n.postMessage(e)
        } else o(e, function (e) {
            t(e.buffer, e.view)
        })
    }!0 === i.leftChannel && (u = 1), 1 === i.numberOfAudioChannels && (u = 1), i.disableLogs || console.log("StereoAudioRecorder is set to record number of channels: ", u), void 0 === i.checkForInactiveTracks && (i.checkForInactiveTracks = !0), this.record = function () {
        if (!1 === f()) throw "Please make sure MediaStream is active.";
        n.length = d.length = 0, c = 0, m && m.connect(r), R = v = !1, s = !0
    }, this.stop = function (o) {
        o = o || function () {}, s = !1, t({
            desiredSampRate: l,
            sampleRate: p,
            numberOfAudioChannels: u,
            internalInterleavedLength: c,
            leftBuffers: n,
            rightBuffers: 1 === u ? [] : d
        }, function (e, t) {
            a.blob = new Blob([t], {
                type: "audio/wav"
            }), a.buffer = new ArrayBuffer(t.buffer.byteLength), a.view = t, a.sampleRate = l || p, a.bufferSize = g, a.length = c, o && o(a.blob), R = !1
        })
    }, Storage.AudioContextConstructor || (Storage.AudioContextConstructor = new Storage.AudioContext);
    var o = Storage.AudioContextConstructor,
        m = o.createMediaStreamSource(e),
        h = [0, 256, 512, 1024, 2048, 4096, 8192, 16384],
        g = void 0 === i.bufferSize ? 4096 : i.bufferSize;
    if (-1 === h.indexOf(g) && (i.disableLogs || console.warn("Legal values for buffer-size are " + JSON.stringify(h, null, "\t"))), o.createJavaScriptNode) r = o.createJavaScriptNode(g, u, u);
    else {
        if (!o.createScriptProcessor) throw "WebAudio API has no support on this browser.";
        r = o.createScriptProcessor(g, u, u)
    }
    m.connect(r), i.bufferSize || (g = r.bufferSize);
    var p = void 0 !== i.sampleRate ? i.sampleRate : o.sampleRate || 44100;
    (p < 22050 || 96e3 < p) && (i.disableLogs || console.warn("sample-rate must be under range 22050 and 96000.")), i.disableLogs || (console.log("sample-rate", p), console.log("buffer-size", g), i.desiredSampRate && console.log("Desired sample-rate", i.desiredSampRate));
    var v = !1;

    function b() {
        n.length = d.length = 0, c = 0, v = s = R = !1, r && (r.onaudioprocess = null, r.disconnect(), r = null), m && (m.disconnect(), m = null)
    }
    this.pause = function () {
        v = !0
    }, this.resume = function () {
        if (!1 === f()) throw "Please make sure MediaStream is active.";
        if (!s) return i.disableLogs || console.log("Seems recording has been restarted."), void this.record();
        v = !1
    }, this.clearRecordedData = function () {
        i.checkForInactiveTracks = !1, s && this.stop(b), b()
    }, this.name = "StereoAudioRecorder";
    var R = !(this.toString = function () {
        return this.name
    });
    r.onaudioprocess = function (e) {
        if (!v)
            if (!1 === f() && (i.disableLogs || console.log("MediaStream seems stopped."), r.disconnect(), s = !1), s) {
                R || (R = !0, i.onAudioProcessStarted && i.onAudioProcessStarted(), i.initCallback && i.initCallback());
                var t = e.inputBuffer.getChannelData(0);
                if (n.push(new Float32Array(t)), 2 === u) {
                    var o = e.inputBuffer.getChannelData(1);
                    d.push(new Float32Array(o))
                }
                c += g, a.recordingLength = c
            } else m.disconnect()
    }, r.connect(o.destination), this.leftchannel = n, this.rightchannel = d, this.numberOfAudioChannels = u, this.desiredSampRate = l, this.sampleRate = p
}

function CanvasRecorder(i, a) {
    if ("undefined" == typeof html2canvas && "canvas" !== i.nodeName.toLowerCase()) throw "Please link: https://cdn.webrtc-experiment.com/screenshot.js";
    (a = a || {}).frameInterval || (a.frameInterval = 10);
    var r = !1;
    ["captureStream", "mozCaptureStream", "webkitCaptureStream"].forEach(function (e) {
        e in document.createElement("canvas") && (r = !0)
    });
    var o, n, d, e = !(!window.webkitRTCPeerConnection && !window.webkitGetUserMedia || !window.chrome),
        t = 50,
        s = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    if (e && s && s[2] && (t = parseInt(s[2], 10)), e && t < 52 && (r = !1), r)
        if (a.disableLogs || console.log("Your browser supports both MediRecorder API and canvas.captureStream!"), i instanceof HTMLCanvasElement) o = i;
        else {
            if (!(i instanceof CanvasRenderingContext2D)) throw "Please pass either HTMLCanvasElement or CanvasRenderingContext2D.";
            o = i.canvas
        } else navigator.mozGetUserMedia && (a.disableLogs || console.error("Canvas recording is NOT supported in Firefox."));
    this.record = function () {
        if (d = !0, r && !a.useWhammyRecorder) {
            var e;
            "captureStream" in o ? e = o.captureStream(25) : "mozCaptureStream" in o ? e = o.mozCaptureStream(25) : "webkitCaptureStream" in o && (e = o.webkitCaptureStream(25));
            try {
                var t = new MediaStream;
                t.addTrack(e.getVideoTracks()[0]), e = t
            } catch (e) {}
            if (!e) throw "captureStream API are NOT available.";
            (n = new MediaStreamRecorder(e, {
                mimeType: "video/webm"
            })).record()
        } else m.frames = [], f = (new Date).getTime(), l();
        a.initCallback && a.initCallback()
    }, this.getWebPImages = function (e) {
        if ("canvas" === i.nodeName.toLowerCase()) {
            var r = m.frames.length;
            m.frames.forEach(function (e, t) {
                var o = r - t;
                a.disableLogs || console.log(o + "/" + r + " frames remaining"), a.onEncodingCallback && a.onEncodingCallback(o, r);
                var i = e.image.toDataURL("image/webp", 1);
                m.frames[t].image = i
            }), a.disableLogs || console.log("Generating WebM"), e()
        } else e()
    };
    var c = !(this.stop = function (t) {
        d = !1;
        var o = this;
        r && n ? n.stop(t) : this.getWebPImages(function () {
            m.compile(function (e) {
                a.disableLogs || console.log("Recording finished!"), o.blob = e, o.blob.forEach && (o.blob = new Blob([], {
                    type: "video/webm"
                })), t && t(o.blob), m.frames = []
            })
        })
    });

    function u() {
        m.frames = [], c = d = !1
    }

    function l() {
        if (c) return f = (new Date).getTime(), setTimeout(l, 500);
        if ("canvas" === i.nodeName.toLowerCase()) {
            var e = (new Date).getTime() - f;
            return f = (new Date).getTime(), m.frames.push({
                image: (t = document.createElement("canvas"), o = t.getContext("2d"), t.width = i.width, t.height = i.height, o.drawImage(i, 0, 0), t),
                duration: e
            }), void(d && setTimeout(l, a.frameInterval))
        }
        var t, o;
        html2canvas(i, {
            grabMouse: void 0 === a.showMousePointer || a.showMousePointer,
            onrendered: function (e) {
                var t = (new Date).getTime() - f;
                if (!t) return setTimeout(l, a.frameInterval);
                f = (new Date).getTime(), m.frames.push({
                    image: e.toDataURL("image/webp", 1),
                    duration: t
                }), d && setTimeout(l, a.frameInterval)
            }
        })
    }
    this.pause = function () {
        c = !0, n instanceof MediaStreamRecorder && n.pause()
    }, this.resume = function () {
        c = !1, n instanceof MediaStreamRecorder ? n.resume() : d || this.record()
    }, this.clearRecordedData = function () {
        d && this.stop(u), u()
    }, this.name = "CanvasRecorder", this.toString = function () {
        return this.name
    };
    var f = (new Date).getTime(),
        m = new Whammy.Video(100)
}

function WhammyRecorder(e, i) {
    function o(e) {
        e = void 0 !== e ? e : 10;
        var t = (new Date).getTime() - s;
        return t ? n ? (s = (new Date).getTime(), setTimeout(o, 100)) : (s = (new Date).getTime(), d.paused && d.play(), u.drawImage(d, 0, 0, w.width, w.height), c.frames.push({
            duration: t,
            image: w.toDataURL("image/webp")
        }), void(a || setTimeout(o, e, e))) : setTimeout(o, e, e)
    }

    function r(o, e, t, i, r) {
        var a = document.createElement("canvas");
        a.width = w.width, a.height = w.height;
        var n, d, s, u = a.getContext("2d"),
            l = [],
            f = -1 === e,
            c = e && 0 < e && e <= o.length ? e : o.length,
            m = 0,
            h = 0,
            g = 0,
            p = Math.sqrt(Math.pow(255, 2) + Math.pow(255, 2) + Math.pow(255, 2)),
            v = t && 0 <= t && t <= 1 ? t : 0,
            b = i && 0 <= i && i <= 1 ? i : 0,
            R = !1;
        d = -1, s = (n = {
                length: c,
                functionToLoop: function (e, t) {
                    var a, n, d, s = function () {
                        !R && d - a <= d * b || (f && (R = !0), l.push(o[t])), e()
                    };
                    if (R) s();
                    else {
                        var c = new Image;
                        c.onload = function () {
                            u.drawImage(c, 0, 0, w.width, w.height);
                            var e = u.getImageData(0, 0, w.width, w.height);
                            a = 0, n = e.data.length, d = e.data.length / 4;
                            for (var t = 0; t < n; t += 4) {
                                var o = e.data[t],
                                    i = e.data[t + 1],
                                    r = e.data[t + 2];
                                Math.sqrt(Math.pow(o - m, 2) + Math.pow(i - h, 2) + Math.pow(r - g, 2)) <= p * v && a++
                            }
                            s()
                        }, c.src = o[t].image
                    }
                }, callback: function () {
                    (l = l.concat(o.slice(c))).length <= 0 && l.push(o[o.length - 1]), r(l)
                }
            }).length,
            function e() {
                ++d !== s ? setTimeout(function () {
                    n.functionToLoop(e, d)
                }, 1) : n.callback()
            }()
    }(i = i || {}).frameInterval || (i.frameInterval = 10), i.disableLogs || console.log("Using frames-interval:", i.frameInterval);
    var a = !(this.record = function () {
            i.width || (i.width = 320), i.height || (i.height = 240), i.video || (i.video = {
                width: i.width,
                height: i.height
            }), i.canvas || (i.canvas = {
                width: i.width,
                height: i.height
            }), w.width = i.canvas.width || 320, w.height = i.canvas.height || 240, u = w.getContext("2d"), i.video && i.video instanceof HTMLVideoElement ? (d = i.video.cloneNode(), i.initCallback && i.initCallback()) : (d = document.createElement("video"), setSrcObject(e, d), d.onloadedmetadata = function () {
                i.initCallback && i.initCallback()
            }, d.width = i.video.width, d.height = i.video.height), d.muted = !0, d.play(), s = (new Date).getTime(), c = new Whammy.Video, i.disableLogs || (console.log("canvas resolutions", w.width, "*", w.height), console.log("video width/height", d.width || w.width, "*", d.height || w.height)), o(i.frameInterval)
        }),
        n = !(this.stop = function (t) {
            t = t || function () {}, a = !0;
            var o = this;
            setTimeout(function () {
                r(c.frames, -1, null, null, function (e) {
                    c.frames = e, i.advertisement && i.advertisement.length && (c.frames = i.advertisement.concat(c.frames)), c.compile(function (e) {
                        o.blob = e, o.blob.forEach && (o.blob = new Blob([], {
                            type: "video/webm"
                        })), t && t(o.blob)
                    })
                })
            }, 10)
        });

    function t() {
        c.frames = [], n = !(a = !0)
    }
    this.pause = function () {
        n = !0
    }, this.resume = function () {
        n = !1, a && this.record()
    }, this.clearRecordedData = function () {
        a || this.stop(t), t()
    }, this.name = "WhammyRecorder", this.toString = function () {
        return this.name
    };
    var d, s, c, w = document.createElement("canvas"),
        u = w.getContext("2d")
}
void 0 !== AudioContext ? Storage.AudioContext = AudioContext : "undefined" != typeof webkitAudioContext && (Storage.AudioContext = webkitAudioContext), void 0 !== RecordRTC && (RecordRTC.Storage = Storage), void 0 !== RecordRTC && (RecordRTC.MediaStreamRecorder = MediaStreamRecorder), void 0 !== RecordRTC && (RecordRTC.StereoAudioRecorder = StereoAudioRecorder), void 0 !== RecordRTC && (RecordRTC.CanvasRecorder = CanvasRecorder), void 0 !== RecordRTC && (RecordRTC.WhammyRecorder = WhammyRecorder);
var Whammy = function () {
    function e(e) {
        this.frames = [], this.duration = e || 1, this.quality = .8
    }

    function a(e) {
        function c(e, o, t) {
            return [{
                data: e,
                id: 231
            }].concat(t.map(function (e) {
                var t = function (e) {
                    var t = 0;
                    e.keyframe && (t |= 128);
                    e.invisible && (t |= 8);
                    e.lacing && (t |= e.lacing << 1);
                    e.discardable && (t |= 1);
                    if (127 < e.trackNum) throw "TrackNumber > 127 not supported";
                    return [128 | e.trackNum, e.timecode >> 8, 255 & e.timecode, t].map(function (e) {
                        return String.fromCharCode(e)
                    }).join("") + e.frame
                }({
                    discardable: 0,
                    frame: e.data.slice(4),
                    invisible: 0,
                    keyframe: 1,
                    lacing: 0,
                    trackNum: 1,
                    timecode: Math.round(o)
                });
                return o += e.duration, {
                    data: t,
                    id: 163
                }
            }))
        }

        function u(e) {
            for (var t = []; 0 < e;) t.push(255 & e), e >>= 8;
            return new Uint8Array(t.reverse())
        }

        function l(e) {
            var t = [];
            e = (e.length % 8 ? new Array(9 - e.length % 8).join("0") : "") + e;
            for (var o = 0; o < e.length; o += 8) t.push(parseInt(e.substr(o, 8), 2));
            return new Uint8Array(t)
        }
        var t = new function (e) {
            var t = function (e) {
                if (e[0]) {
                    for (var t = e[0].width, o = e[0].height, i = e[0].duration, r = 1; r < e.length; r++) i += e[r].duration;
                    return {
                        duration: i,
                        width: t,
                        height: o
                    }
                }
                postMessage({
                    error: "Something went wrong. Maybe WebP format is not supported in the current browser."
                })
            }(e);
            if (!t) return [];
            for (var o, i = [{
                id: 440786851,
                data: [{
                    data: 1,
                    id: 17030
                }, {
                    data: 1,
                    id: 17143
                }, {
                    data: 4,
                    id: 17138
                }, {
                    data: 8,
                    id: 17139
                }, {
                    data: "webm",
                    id: 17026
                }, {
                    data: 2,
                    id: 17031
                }, {
                    data: 2,
                    id: 17029
                }]
            }, {
                id: 408125543,
                data: [{
                    id: 357149030,
                    data: [{
                        data: 1e6,
                        id: 2807729
                    }, {
                        data: "whammy",
                        id: 19840
                    }, {
                        data: "whammy",
                        id: 22337
                    }, {
                        data: (o = t.duration, [].slice.call(new Uint8Array(new Float64Array([o]).buffer), 0).map(function (e) {
                            return String.fromCharCode(e)
                        }).reverse().join("")),
                        id: 17545
                    }]
                }, {
                    id: 374648427,
                    data: [{
                        id: 174,
                        data: [{
                            data: 1,
                            id: 215
                        }, {
                            data: 1,
                            id: 29637
                        }, {
                            data: 0,
                            id: 156
                        }, {
                            data: "und",
                            id: 2274716
                        }, {
                            data: "V_VP8",
                            id: 134
                        }, {
                            data: "VP8",
                            id: 2459272
                        }, {
                            data: 1,
                            id: 131
                        }, {
                            id: 224,
                            data: [{
                                data: t.width,
                                id: 176
                            }, {
                                data: t.height,
                                id: 186
                            }]
                        }]
                    }]
                }]
            }], r = 0, a = 0; r < e.length;) {
                for (var n = [], d = 0; n.push(e[r]), d += e[r].duration, ++r < e.length && d < 3e4;);
                var s = {
                    id: 524531317,
                    data: c(a, 0, n)
                };
                i[1].data.push(s), a += d
            }
            return function e(t) {
                for (var o = [], i = 0; i < t.length; i++) {
                    var r = t[i].data;
                    "object" == typeof r && (r = e(r)), "number" == typeof r && (r = l(r.toString(2))), "string" == typeof r && (r = new Uint8Array(r.split("").map(function (e) {
                        return e.charCodeAt(0)
                    })));
                    var a = r.size || r.byteLength || r.length,
                        n = Math.ceil(Math.ceil(Math.log(a) / Math.log(2)) / 8),
                        d = a.toString(2),
                        s = new Array(7 * n + 7 + 1 - d.length).join("0") + d,
                        c = new Array(n).join("0") + "1" + s;
                    o.push(u(t[i].id)), o.push(l(c)), o.push(r)
                }
                return new Blob(o, {
                    type: "video/webm"
                })
            }(i)
        }(e.map(function (e) {
            var t = function (e) {
                for (var t = e.RIFF[0].WEBP[0], o = t.indexOf("*"), i = 0, r = []; i < 4; i++) r[i] = t.charCodeAt(o + 3 + i);
                return {
                    width: 16383 & (r[1] << 8 | r[0]),
                    height: 16383 & (r[3] << 8 | r[2]),
                    data: t,
                    riff: e
                }
            }(function e(t) {
                for (var o, i = 0, r = {}; i < t.length;) {
                    var a = t.substr(i, 4),
                        n = (o = i, parseInt(t.substr(o + 4, 4).split("").map(function (e) {
                            var t = e.charCodeAt(0).toString(2);
                            return new Array(8 - t.length + 1).join("0") + t
                        }).join(""), 2)),
                        d = t.substr(i + 4 + 4, n);
                    i += 8 + n, r[a] = r[a] || [], "RIFF" === a || "LIST" === a ? r[a].push(e(d)) : r[a].push(d)
                }
                return r
            }(atob(e.image.slice(23))));
            return t.duration = e.duration, t
        }));
        postMessage(t)
    }
    return e.prototype.add = function (e, t) {
        if ("canvas" in e && (e = e.canvas), "toDataURL" in e && (e = e.toDataURL("image/webp", this.quality)), !/^data:image\/webp;base64,/gi.test(e)) throw "Input must be formatted properly as a base64 encoded DataURI of type image/webp";
        this.frames.push({
            image: e,
            duration: t || this.duration
        })
    }, e.prototype.compile = function (t) {
        var e, o, i, r = (e = a, o = URL.createObjectURL(new Blob([e.toString(), "this.onmessage =  function (e) {" + e.name + "(e.data);}"], {
            type: "application/javascript"
        })), i = new Worker(o), URL.revokeObjectURL(o), i);
        r.onmessage = function (e) {
            e.data.error ? console.error(e.data.error) : t(e.data)
        }, r.postMessage(this.frames)
    }, {
        Video: e
    }
}();
void 0 !== RecordRTC && (RecordRTC.Whammy = Whammy);
var DiskStorage = {
    init: function () {
        var o = this;
        if ("undefined" != typeof indexedDB && void 0 !== indexedDB.open) {
            var i, e = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, ""),
                t = indexedDB.open(e, 1);
            t.onerror = o.onError, t.onsuccess = function () {
                ((i = t.result).onerror = o.onError, i.setVersion) ? 1 !== i.version ? i.setVersion(1).onsuccess = function () {
                    r(i), a()
                } : a(): a()
            }, t.onupgradeneeded = function (e) {
                r(e.target.result)
            }
        } else console.error("IndexedDB API are not available in this browser.");

        function r(e) {
            e.createObjectStore(o.dataStoreName)
        }

        function a() {
            var e = i.transaction([o.dataStoreName], "readwrite");

            function t(t) {
                e.objectStore(o.dataStoreName).get(t).onsuccess = function (e) {
                    o.callback && o.callback(e.target.result, t)
                }
            }
            o.videoBlob && e.objectStore(o.dataStoreName).put(o.videoBlob, "videoBlob"), o.gifBlob && e.objectStore(o.dataStoreName).put(o.gifBlob, "gifBlob"), o.audioBlob && e.objectStore(o.dataStoreName).put(o.audioBlob, "audioBlob"), t("audioBlob"), t("videoBlob"), t("gifBlob")
        }
    }, Fetch: function (e) {
        return this.callback = e, this.init(), this
    }, Store: function (e) {
        return this.audioBlob = e.audioBlob, this.videoBlob = e.videoBlob, this.gifBlob = e.gifBlob, this.init(), this
    }, onError: function (e) {
        console.error(JSON.stringify(e, null, "\t"))
    }, dataStoreName: "recordRTC",
    dbName: null
};

function GifRecorder(e, o) {
    if ("undefined" == typeof GIFEncoder) {
        var t = document.createElement("script");
        t.src = "https://cdn.webrtc-experiment.com/gif-recorder.js", (document.body || document.documentElement).appendChild(t)
    }
    o = o || {};
    var i = e instanceof CanvasRenderingContext2D || e instanceof HTMLCanvasElement;
    this.record = function () {
        "undefined" != typeof GIFEncoder && d ? (i || (o.width || (o.width = s.offsetWidth || 320), o.height || (o.height = s.offsetHeight || 240), o.video || (o.video = {
            width: o.width,
            height: o.height
        }), o.canvas || (o.canvas = {
            width: o.width,
            height: o.height
        }), a.width = o.canvas.width || 320, a.height = o.canvas.height || 240, s.width = o.video.width || 320, s.height = o.video.height || 240), (u = new GIFEncoder).setRepeat(0), u.setDelay(o.frameRate || 200), u.setQuality(o.quality || 10), u.start(), "function" == typeof o.onGifRecordingStarted && o.onGifRecordingStarted(), Date.now(), l = requestAnimationFrame(function e(t) {
            if (!0 !== f.clearedRecordedData) {
                if (r) return setTimeout(function () {
                    e(t)
                }, 100);
                l = requestAnimationFrame(e), void 0 === typeof c && (c = t), t - c < 90 || (!i && s.paused && s.play(), i || n.drawImage(s, 0, 0, a.width, a.height), o.onGifPreview && o.onGifPreview(a.toDataURL("image/png")), u.addFrame(n), c = t)
            }
        }), o.initCallback && o.initCallback()) : setTimeout(f.record, 1e3)
    };
    var r = !(this.stop = function (e) {
        e = e || function () {}, l && cancelAnimationFrame(l), Date.now(), this.blob = new Blob([new Uint8Array(u.stream().bin)], {
            type: "image/gif"
        }), e(this.blob), u.stream().bin = []
    });
    this.pause = function () {
        r = !0
    }, this.resume = function () {
        r = !1
    }, this.clearRecordedData = function () {
        f.clearedRecordedData = !0, u && (u.stream().bin = [])
    }, this.name = "GifRecorder", this.toString = function () {
        return this.name
    };
    var a = document.createElement("canvas"),
        n = a.getContext("2d");
    i && (e instanceof CanvasRenderingContext2D ? a = (n = e).canvas : e instanceof HTMLCanvasElement && (n = e.getContext("2d"), a = e));
    var d = !0;
    if (!i) {
        var s = document.createElement("video");
        s.muted = !0, s.autoplay = !0, d = !1, s.onloadedmetadata = function () {
            d = !0
        }, setSrcObject(e, s), s.play()
    }
    var c, u, l = null,
        f = this
}

function MultiStreamsMixer(i) {
    var r = [],
        n = !1,
        a = document.createElement("canvas"),
        d = a.getContext("2d");
    a.style = "opacity:0;position:absolute;z-index:-1;top: -100000000;left:-1000000000; margin-top:-1000000000;margin-left:-1000000000;", (document.body || document.documentElement).appendChild(a), this.disableLogs = !1, this.frameInterval = 10, this.width = 360, this.height = 240, this.useGainNode = !0;
    var s = this,
        e = window.AudioContext;
    void 0 === e && ("undefined" != typeof webkitAudioContext && (e = webkitAudioContext), "undefined" != typeof mozAudioContext && (e = mozAudioContext));
    var c = window.URL;
    void 0 === c && "undefined" != typeof webkitURL && (c = webkitURL), "undefined" != typeof navigator && void 0 === navigator.getUserMedia && (void 0 !== navigator.webkitGetUserMedia && (navigator.getUserMedia = navigator.webkitGetUserMedia), void 0 !== navigator.mozGetUserMedia && (navigator.getUserMedia = navigator.mozGetUserMedia));
    var o = window.MediaStream;
    void 0 === o && "undefined" != typeof webkitMediaStream && (o = webkitMediaStream), void 0 !== o && ("getVideoTracks" in o.prototype || (o.prototype.getVideoTracks = function () {
        if (!this.getTracks) return [];
        var t = [];
        return this.getTracks.forEach(function (e) {
            -1 !== e.kind.toString().indexOf("video") && t.push(e)
        }), t
    }, o.prototype.getAudioTracks = function () {
        if (!this.getTracks) return [];
        var t = [];
        return this.getTracks.forEach(function (e) {
            -1 !== e.kind.toString().indexOf("audio") && t.push(e)
        }), t
    }), void 0 === o.prototype.stop && (o.prototype.stop = function () {
        this.getTracks().forEach(function (e) {
            e.stop()
        })
    }));
    var u = {};

    function l() {
        if (!n) {
            var e = r.length,
                t = !1,
                o = [];
            if (r.forEach(function (e) {
                e.stream || (e.stream = {}), e.stream.fullcanvas ? t = e : o.push(e)
            }), t) a.width = t.stream.width, a.height = t.stream.height;
            else if (o.length) {
                a.width = 1 < e ? 2 * o[0].width : o[0].width;
                var i = 1;
                3 !== e && 4 !== e || (i = 2), 5 !== e && 6 !== e || (i = 3), 7 !== e && 8 !== e || (i = 4), 9 !== e && 10 !== e || (i = 5), a.height = o[0].height * i
            } else a.width = s.width || 360, a.height = s.height || 240;
            t && t instanceof HTMLVideoElement && f(t), o.forEach(function (e, t) {
                f(e, t)
            }), setTimeout(l, s.frameInterval)
        }
    }

    function f(e, t) {
        if (!n) {
            var o = 0,
                i = 0,
                r = e.width,
                a = e.height;
            1 === t && (o = e.width), 2 === t && (i = e.height), 3 === t && (o = e.width, i = e.height), 4 === t && (i = 2 * e.height), 5 === t && (o = e.width, i = 2 * e.height), 6 === t && (i = 3 * e.height), 7 === t && (o = e.width, i = 3 * e.height), void 0 !== e.stream.left && (o = e.stream.left), void 0 !== e.stream.top && (i = e.stream.top), void 0 !== e.stream.width && (r = e.stream.width), void 0 !== e.stream.height && (a = e.stream.height), d.drawImage(e, o, i, r, a), "function" == typeof e.stream.onRender && e.stream.onRender(d, o, i, r, a, t)
        }
    }

    function m(e) {
        var t = document.createElement("video");
        return function t(o, i, e) {
            if ("createObjectURL" in c && !e) try {
                i.src = c.createObjectURL(o)
            } catch (e) {
                return void t(o, i, !0)
            } else "srcObject" in i ? i.srcObject = o : "mozSrcObject" in i ? i.mozSrcObject = o : alert("createObjectURL/srcObject both are not supported.")
        }(e, t), t.muted = !0, t.volume = 0, t.width = e.width || s.width || 360, t.height = e.height || s.height || 240, t.play(), t
    }

    function h(e) {
        r = [], (e = e || i).forEach(function (e) {
            if (e.getVideoTracks().length) {
                var t = m(e);
                t.stream = e, r.push(t)
            }
        })
    }
    void 0 !== e ? u.AudioContext = e : "undefined" != typeof webkitAudioContext && (u.AudioContext = webkitAudioContext), this.startDrawingFrames = function () {
        l()
    }, this.appendStreams = function (e) {
        if (!e) throw "First parameter is required.";
        e instanceof Array || (e = [e]), i.concat(e), e.forEach(function (e) {
            if (e.getVideoTracks().length) {
                var t = m(e);
                t.stream = e, r.push(t)
            }
            if (e.getAudioTracks().length && s.audioContext) {
                var o = s.audioContext.createMediaStreamSource(e);
                o.connect(s.audioDestination), s.audioSources.push(o)
            }
        })
    }, this.releaseStreams = function () {
        r = [], n = !0, s.gainNode && (s.gainNode.disconnect(), s.gainNode = null), s.audioSources.length && (s.audioSources.forEach(function (e) {
            e.disconnect()
        }), s.audioSources = []), s.audioDestination && (s.audioDestination.disconnect(), s.audioDestination = null), s.audioContext = null, d.clearRect(0, 0, a.width, a.height), a.stream && (a.stream.stop(), a.stream = null)
    }, this.resetVideoStreams = function (e) {
        !e || e instanceof Array || (e = [e]), h(e)
    }, this.name = "MultiStreamsMixer", this.toString = function () {
        return this.name
    }, this.getMixedStream = function () {
        n = !1;
        var t = function () {
                var e;
                h(), "captureStream" in a ? e = a.captureStream() : "mozCaptureStream" in a ? e = a.mozCaptureStream() : s.disableLogs || console.error("Upgrade to latest Chrome or otherwise enable this flag: chrome://flags/#enable-experimental-web-platform-features");
                var t = new o;
                return e.getVideoTracks().forEach(function (e) {
                    t.addTrack(e)
                }), a.stream = t
            }(),
            e = function () {
                u.AudioContextConstructor || (u.AudioContextConstructor = new u.AudioContext), s.audioContext = u.AudioContextConstructor, s.audioSources = [], !0 === s.useGainNode && (s.gainNode = s.audioContext.createGain(), s.gainNode.connect(s.audioContext.destination), s.gainNode.gain.value = 0);
                var o = 0;
                if (i.forEach(function (e) {
                    if (e.getAudioTracks().length) {
                        o++;
                        var t = s.audioContext.createMediaStreamSource(e);
                        !0 === s.useGainNode && t.connect(s.gainNode), s.audioSources.push(t)
                    }
                }), o) return s.audioDestination = s.audioContext.createMediaStreamDestination(), s.audioSources.forEach(function (e) {
                    e.connect(s.audioDestination)
                }), s.audioDestination.stream
            }();
        return e && e.getAudioTracks().forEach(function (e) {
            t.addTrack(e)
        }), i.forEach(function (e) {
            e.fullcanvas
        }), t
    }
}

function MultiStreamRecorder(o, e) {
    o = o || [];
    var i, r, a = this;
    (e = e || {
        mimeType: "video/webm",
        video: {
            width: 360,
            height: 240
        }
    }).frameInterval || (e.frameInterval = 10), e.video || (e.video = {}), e.video.width || (e.video.width = 360), e.video.height || (e.video.height = 240), this.record = function () {
        var t;
        i = new MultiStreamsMixer(o), (t = [], o.forEach(function (e) {
            e.getVideoTracks().forEach(function (e) {
                t.push(e)
            })
        }), t).length && (i.frameInterval = e.frameInterval || 10, i.width = e.video.width || 360, i.height = e.video.height || 240, i.startDrawingFrames()), e.previewStream && "function" == typeof e.previewStream && e.previewStream(i.getMixedStream()), (r = new MediaStreamRecorder(i.getMixedStream(), e)).record()
    }, this.stop = function (t) {
        r && r.stop(function (e) {
            a.blob = e, t(e), a.clearRecordedData()
        })
    }, this.pause = function () {
        r && r.pause()
    }, this.resume = function () {
        r && r.resume()
    }, this.clearRecordedData = function () {
        r && (r.clearRecordedData(), r = null), i && (i.releaseStreams(), i = null)
    }, this.addStreams = function (e) {
        if (!e) throw "First parameter is required.";
        e instanceof Array || (e = [e]), o.concat(e), r && i && i.appendStreams(e)
    }, this.resetVideoStreams = function (e) {
        i && (!e || e instanceof Array || (e = [e]), i.resetVideoStreams(e))
    }, this.name = "MultiStreamRecorder", this.toString = function () {
        return this.name
    }
}

function RecordRTCPromisesHandler(e, t) {
    if (!this) throw 'Use "new RecordRTCPromisesHandler()"';
    if (void 0 === e) throw 'First argument "MediaStream" is required.';
    var i = this;
    i.recordRTC = new RecordRTC(e, t), this.startRecording = function () {
        return new Promise(function (e, t) {
            try {
                i.recordRTC.startRecording(), e()
            } catch (e) {
                t(e)
            }
        })
    }, this.stopRecording = function () {
        return new Promise(function (t, o) {
            try {
                i.recordRTC.stopRecording(function (e) {
                    i.blob = i.recordRTC.getBlob(), t(e)
                })
            } catch (e) {
                o(e)
            }
        })
    }, this.getDataURL = function (e) {
        return new Promise(function (t, o) {
            try {
                i.recordRTC.getDataURL(function (e) {
                    t(e)
                })
            } catch (e) {
                o(e)
            }
        })
    }, this.getBlob = function () {
        return i.recordRTC.getBlob()
    }, this.blob = null
}
void 0 !== RecordRTC && (RecordRTC.DiskStorage = DiskStorage), void 0 !== RecordRTC && (RecordRTC.GifRecorder = GifRecorder), void 0 !== RecordRTC && (RecordRTC.MultiStreamRecorder = MultiStreamRecorder), void 0 !== RecordRTC && (RecordRTC.RecordRTCPromisesHandler = RecordRTCPromisesHandler);